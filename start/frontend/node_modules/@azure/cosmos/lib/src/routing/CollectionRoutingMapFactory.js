"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require(".");
const common_1 = require("../common");
function compareRanges(a, b) {
    const aVal = a[0][common_1.Constants.PartitionKeyRange.MinInclusive];
    const bVal = b[0][common_1.Constants.PartitionKeyRange.MinInclusive];
    if (aVal > bVal) {
        return 1;
    }
    if (aVal < bVal) {
        return -1;
    }
    return 0;
}
/** @hidden */
class CollectionRoutingMapFactory {
    static createCompleteRoutingMap(partitionKeyRangeInfoTuppleList, collectionUniqueId) {
        const rangeById = {}; // TODO: any
        const rangeByInfo = {}; // TODO: any
        let sortedRanges = [];
        // the for loop doesn't invoke any async callback
        for (const r of partitionKeyRangeInfoTuppleList) {
            rangeById[r[0][common_1.Constants.PartitionKeyRange.Id]] = r;
            rangeByInfo[r[1]] = r[0];
            sortedRanges.push(r);
        }
        sortedRanges = sortedRanges.sort(compareRanges);
        const partitionKeyOrderedRange = sortedRanges.map(r => r[0]);
        const orderedPartitionInfo = sortedRanges.map(r => r[1]);
        if (!this._isCompleteSetOfRange(partitionKeyOrderedRange)) {
            return undefined;
        }
        return new _1.InMemoryCollectionRoutingMap(rangeById, rangeByInfo, partitionKeyOrderedRange, orderedPartitionInfo, collectionUniqueId);
    }
    static _isCompleteSetOfRange(partitionKeyOrderedRange) {
        // TODO: any
        let isComplete = false;
        if (partitionKeyOrderedRange.length > 0) {
            const firstRange = partitionKeyOrderedRange[0];
            const lastRange = partitionKeyOrderedRange[partitionKeyOrderedRange.length - 1];
            isComplete =
                firstRange[common_1.Constants.PartitionKeyRange.MinInclusive] ===
                    common_1.Constants.EffectiveParitionKeyConstants.MinimumInclusiveEffectivePartitionKey;
            isComplete =
                isComplete &&
                    lastRange[common_1.Constants.PartitionKeyRange.MaxExclusive] ===
                        common_1.Constants.EffectiveParitionKeyConstants.MaximumExclusiveEffectivePartitionKey;
            for (let i = 1; i < partitionKeyOrderedRange.length; i++) {
                const previousRange = partitionKeyOrderedRange[i - 1];
                const currentRange = partitionKeyOrderedRange[i];
                isComplete =
                    isComplete &&
                        previousRange[common_1.Constants.PartitionKeyRange.MaxExclusive] ===
                            currentRange[common_1.Constants.PartitionKeyRange.MinInclusive];
                if (!isComplete) {
                    if (previousRange[common_1.Constants.PartitionKeyRange.MaxExclusive] >
                        currentRange[common_1.Constants.PartitionKeyRange.MinInclusive]) {
                        throw Error("Ranges overlap");
                    }
                    break;
                }
            }
        }
        return isComplete;
    }
}
exports.CollectionRoutingMapFactory = CollectionRoutingMapFactory;
//# sourceMappingURL=CollectionRoutingMapFactory.js.map