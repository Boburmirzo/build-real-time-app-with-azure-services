"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const common_1 = require("../common");
const defaultQueryExecutionContext_1 = require("./defaultQueryExecutionContext");
const FetchResult_1 = require("./FetchResult");
const headerUtils_1 = require("./headerUtils");
/** @hidden */
const HttpHeaders = common_1.Constants;
/** @hidden */
var DocumentProducerStates;
(function (DocumentProducerStates) {
    DocumentProducerStates["started"] = "started";
    DocumentProducerStates["inProgress"] = "inProgress";
    DocumentProducerStates["ended"] = "ended";
})(DocumentProducerStates || (DocumentProducerStates = {}));
/** @hidden */
class DocumentProducer {
    /**
     * Provides the Target Partition Range Query Execution Context.
     * @constructor DocumentProducer
     * @param {ClientContext} clientContext        - The service endpoint to use to create the client.
     * @param {String} collectionLink                - Represents collection link
     * @param {SqlQuerySpec | string} query          - A SQL query.
     * @param {object} targetPartitionKeyRange       - Query Target Partition key Range
     * @ignore
     */
    constructor(clientContext, collectionLink, query, targetPartitionKeyRange, // TODO: any partition key range
    options) {
        this.clientContext = clientContext;
        this.fetchFunction = (options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const path = common_1.Helper.getPathFromLink(this.collectionLink, "docs");
            const id = common_1.Helper.getIdFromLink(this.collectionLink);
            return this.clientContext.queryFeed(path, "docs", id, (result) => result.Documents, // TODO: any
            this.query, options, this.targetPartitionKeyRange["id"]);
        });
        // TODO: any options
        this.collectionLink = collectionLink;
        this.query = query;
        this.targetPartitionKeyRange = targetPartitionKeyRange;
        this.fetchResults = [];
        this.state = DocumentProducer.STATES.started;
        this.allFetched = false;
        this.err = undefined;
        this.previousContinuationToken = undefined;
        this.continuationToken = undefined;
        this.respHeaders = headerUtils_1.HeaderUtils.getInitialHeader();
        // tslint:disable-next-line:no-shadowed-variable
        this.internalExecutionContext = new defaultQueryExecutionContext_1.DefaultQueryExecutionContext(clientContext, query, options, this.fetchFunction);
        this.state = DocumentProducer.STATES.inProgress;
    }
    /**
     * Synchronously gives the contiguous buffered results (stops at the first non result) if any
     * @returns {Object}       - buffered current items if any
     * @ignore
     */
    peekBufferedItems() {
        const bufferedResults = [];
        for (let i = 0, done = false; i < this.fetchResults.length && !done; i++) {
            const fetchResult = this.fetchResults[i];
            switch (fetchResult.fetchResultType) {
                case FetchResult_1.FetchResultType.Done:
                    done = true;
                    break;
                case FetchResult_1.FetchResultType.Exception:
                    done = true;
                    break;
                case FetchResult_1.FetchResultType.Result:
                    bufferedResults.push(fetchResult.feedResponse);
                    break;
            }
        }
        return bufferedResults;
    }
    hasMoreResults() {
        return this.internalExecutionContext.hasMoreResults() || this.fetchResults.length !== 0;
    }
    gotSplit() {
        const fetchResult = this.fetchResults[0];
        if (fetchResult.fetchResultType === FetchResult_1.FetchResultType.Exception) {
            if (DocumentProducer._needPartitionKeyRangeCacheRefresh(fetchResult.error)) {
                return true;
            }
        }
        return false;
    }
    _getAndResetActiveResponseHeaders() {
        const ret = this.respHeaders;
        this.respHeaders = headerUtils_1.HeaderUtils.getInitialHeader();
        return ret;
    }
    _updateStates(err, allFetched) {
        // TODO: any Error
        if (err) {
            this.state = DocumentProducer.STATES.ended;
            this.err = err;
            return;
        }
        if (allFetched) {
            this.allFetched = true;
        }
        if (this.allFetched && this.peekBufferedItems().length === 0) {
            this.state = DocumentProducer.STATES.ended;
        }
        if (this.internalExecutionContext.continuation === this.continuationToken) {
            // nothing changed
            return;
        }
        this.previousContinuationToken = this.continuationToken;
        this.continuationToken = this.internalExecutionContext.continuation;
    }
    static _needPartitionKeyRangeCacheRefresh(error) {
        // TODO: error
        return (error.code === common_1.StatusCodes.Gone &&
            "substatus" in error &&
            error["substatus"] === common_1.SubStatusCodes.PartitionKeyRangeGone);
    }
    /**
     * Fetches and bufferes the next page of results and executes the given callback
     * @memberof DocumentProducer
     * @instance
     */
    bufferMore() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.err) {
                throw this.err;
            }
            try {
                const { result: resources, headers: headerResponse } = yield this.internalExecutionContext.fetchMore();
                this._updateStates(undefined, resources === undefined);
                if (resources !== undefined) {
                    // some more results
                    resources.forEach((element) => {
                        // TODO: resources any
                        this.fetchResults.push(new FetchResult_1.FetchResult(element, undefined));
                    });
                }
                // need to modify the header response so that the query metrics are per partition
                if (headerResponse != null && common_1.Constants.HttpHeaders.QueryMetrics in headerResponse) {
                    // "0" is the default partition before one is actually assigned.
                    const queryMetrics = headerResponse[common_1.Constants.HttpHeaders.QueryMetrics]["0"];
                    // Wraping query metrics in a object where the keys are the partition key range.
                    headerResponse[common_1.Constants.HttpHeaders.QueryMetrics] = {};
                    headerResponse[common_1.Constants.HttpHeaders.QueryMetrics][this.targetPartitionKeyRange.id] = queryMetrics;
                }
                return { result: resources, headers: headerResponse };
            }
            catch (err) {
                // TODO: any error
                if (DocumentProducer._needPartitionKeyRangeCacheRefresh(err)) {
                    // Split just happend
                    // Buffer the error so the execution context can still get the feedResponses in the itemBuffer
                    const bufferedError = new FetchResult_1.FetchResult(undefined, err);
                    this.fetchResults.push(bufferedError);
                    // Putting a dummy result so that the rest of code flows
                    return { result: [bufferedError], headers: err.headers };
                }
                else {
                    this._updateStates(err, err.resources === undefined);
                    throw err;
                }
            }
        });
    }
    /**
     * Synchronously gives the bufferend current item if any
     * @returns {Object}       - buffered current item if any
     * @ignore
     */
    getTargetParitionKeyRange() {
        return this.targetPartitionKeyRange;
    }
    /**
     * Execute a provided function on the next element in the DocumentProducer.
     * @memberof DocumentProducer
     * @instance
     * @param {callback} callback - Function to execute for each element. the function \
     * takes two parameters error, element.
     */
    nextItem() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.err) {
                this._updateStates(this.err, undefined);
                throw this.err;
            }
            try {
                const { result, headers } = yield this.current();
                const fetchResult = this.fetchResults.shift();
                this._updateStates(undefined, result === undefined);
                if (fetchResult.feedResponse !== result) {
                    throw new Error(`Expected ${fetchResult.feedResponse} to equal ${result}`);
                }
                switch (fetchResult.fetchResultType) {
                    case FetchResult_1.FetchResultType.Done:
                        return { result: undefined, headers };
                    case FetchResult_1.FetchResultType.Exception:
                        fetchResult.error.headers = headers;
                        throw fetchResult.error;
                    case FetchResult_1.FetchResultType.Result:
                        return { result: fetchResult.feedResponse, headers };
                }
            }
            catch (err) {
                this._updateStates(err, err.item === undefined);
                throw err;
            }
        });
    }
    /**
     * Retrieve the current element on the DocumentProducer.
     * @memberof DocumentProducer
     * @instance
     * @param {callback} callback - Function to execute for the current element. \
     * the function takes two parameters error, element.
     */
    current() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // If something is buffered just give that
            if (this.fetchResults.length > 0) {
                const fetchResult = this.fetchResults[0];
                // Need to unwrap fetch results
                switch (fetchResult.fetchResultType) {
                    case FetchResult_1.FetchResultType.Done:
                        return {
                            result: undefined,
                            headers: this._getAndResetActiveResponseHeaders()
                        };
                    case FetchResult_1.FetchResultType.Exception:
                        fetchResult.error.headers = this._getAndResetActiveResponseHeaders();
                        throw fetchResult.error;
                    case FetchResult_1.FetchResultType.Result:
                        return {
                            result: fetchResult.feedResponse,
                            headers: this._getAndResetActiveResponseHeaders()
                        };
                }
            }
            // If there isn't anymore items left to fetch then let the user know.
            if (this.allFetched) {
                return {
                    result: undefined,
                    headers: this._getAndResetActiveResponseHeaders()
                };
            }
            // If there are no more bufferd items and there are still items to be fetched then buffer more
            try {
                const { result, headers } = yield this.bufferMore();
                if (result === undefined) {
                    return { result: undefined, headers };
                }
                headerUtils_1.HeaderUtils.mergeHeaders(this.respHeaders, headers);
                return this.current();
            }
            catch (err) {
                throw err;
            }
        });
    }
}
// // Static Members
// STATES: Object.freeze({ started: "started", inProgress: "inProgress", ended: "ended" })
DocumentProducer.STATES = DocumentProducerStates;
exports.DocumentProducer = DocumentProducer;
//# sourceMappingURL=documentProducer.js.map