"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const Aggregators_1 = require("../Aggregators");
/** @hidden */
class AggregateEndpointComponent {
    /**
     * Represents an endpoint in handling aggregate queries.
     * @constructor AggregateEndpointComponent
     * @param { object } executionContext - Underlying Execution Context
     * @ignore
     */
    constructor(executionContext, aggregateOperators) {
        this.executionContext = executionContext;
        // TODO: any
        this.executionContext = executionContext;
        this.localAggregators = [];
        aggregateOperators.forEach((aggregateOperator) => {
            switch (aggregateOperator) {
                case "Average":
                    this.localAggregators.push(new Aggregators_1.AverageAggregator());
                    break;
                case "Count":
                    this.localAggregators.push(new Aggregators_1.CountAggregator());
                    break;
                case "Max":
                    this.localAggregators.push(new Aggregators_1.MaxAggregator());
                    break;
                case "Min":
                    this.localAggregators.push(new Aggregators_1.MinAggregator());
                    break;
                case "Sum":
                    this.localAggregators.push(new Aggregators_1.SumAggregator());
                    break;
            }
        });
    }
    /**
     * Populate the aggregated values
     * @ignore
     */
    _getAggregateResult() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.toArrayTempResources = [];
            this.aggregateValues = [];
            this.aggregateValuesIndex = -1;
            try {
                const { result: resources, headers } = yield this._getQueryResults();
                resources.forEach((resource) => {
                    // TODO: any
                    this.localAggregators.forEach(aggregator => {
                        let itemValue;
                        // Get the value of the first property if it exists
                        if (resource && Object.keys(resource).length > 0) {
                            const key = Object.keys(resource)[0];
                            itemValue = resource[key];
                        }
                        aggregator.aggregate(itemValue);
                    });
                });
                // Get the aggregated results
                this.localAggregators.forEach(aggregator => {
                    this.aggregateValues.push(aggregator.getResult());
                });
                return { result: this.aggregateValues, headers };
            }
            catch (err) {
                throw err;
            }
        });
    }
    /**
     * Get the results of queries from all partitions
     * @ignore
     */
    _getQueryResults() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { result: item, headers } = yield this.executionContext.nextItem();
                if (item === undefined) {
                    // no more results
                    return { result: this.toArrayTempResources, headers };
                }
                this.toArrayTempResources = this.toArrayTempResources.concat(item);
                return this._getQueryResults();
            }
            catch (err) {
                throw err;
            }
        });
    }
    /**
     * Execute a provided function on the next element in the AggregateEndpointComponent.
     * @memberof AggregateEndpointComponent
     * @instance
     * @param {callback} callback - Function to execute for each element. \
     * the function takes two parameters error, element.
     */
    nextItem() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                let resHeaders;
                let resources;
                if (this.aggregateValues === undefined) {
                    ({ result: resources, headers: resHeaders } = yield this._getAggregateResult());
                }
                const resource = this.aggregateValuesIndex < this.aggregateValues.length
                    ? this.aggregateValues[++this.aggregateValuesIndex]
                    : undefined;
                return { result: resource, headers: resHeaders };
            }
            catch (err) {
                throw err;
            }
        });
    }
    /**
     * Retrieve the current element on the AggregateEndpointComponent.
     * @memberof AggregateEndpointComponent
     * @instance
     * @param {callback} callback - Function to execute for the current element. \
     * the function takes two parameters error, element.
     */
    current() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.aggregateValues === undefined) {
                const { result: resouces, headers } = yield this._getAggregateResult();
                return {
                    result: this.aggregateValues[this.aggregateValuesIndex],
                    headers
                };
            }
            else {
                return {
                    result: this.aggregateValues[this.aggregateValuesIndex],
                    headers: undefined
                };
            }
        });
    }
    /**
     * Determine if there are still remaining resources to processs.
     * @memberof AggregateEndpointComponent
     * @instance
     * @returns {Boolean} true if there is other elements to process in the AggregateEndpointComponent.
     */
    hasMoreResults() {
        return this.aggregateValues != null && this.aggregateValuesIndex < this.aggregateValues.length - 1;
    }
}
exports.AggregateEndpointComponent = AggregateEndpointComponent;
//# sourceMappingURL=AggregateEndpointComponent.js.map