"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const _1 = require(".");
const common_1 = require("../common");
/** @hidden */
class ProxyQueryExecutionContext {
    constructor(clientContext, query, options, // TODO: any options
    fetchFunctions, resourceLink) {
        this.clientContext = clientContext;
        this.query = query;
        this.options = options;
        this.fetchFunctions = fetchFunctions;
        this.resourceLink = resourceLink;
        this.query = query;
        this.fetchFunctions = fetchFunctions;
        // clone options
        this.options = JSON.parse(JSON.stringify(options || {}));
        this.resourceLink = resourceLink;
        this.queryExecutionContext = new _1.DefaultQueryExecutionContext(this.clientContext, this.query, this.options, this.fetchFunctions);
    }
    /**
     * Execute a provided function on the next element in the ProxyQueryExecutionContext.
     * @memberof ProxyQueryExecutionContext
     * @instance
     * @param {callback} callback - Function to execute for each element. \
     * the function takes two parameters error, element.
     */
    nextItem() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const r = yield this.queryExecutionContext.nextItem();
                return r;
            }
            catch (err) {
                if (this._hasPartitionedExecutionInfo(err)) {
                    // if this's a partitioned execution info switches the execution context
                    const partitionedExecutionInfo = this._getParitionedExecutionInfo(err);
                    this.queryExecutionContext = this._createPipelinedExecutionContext(partitionedExecutionInfo);
                    try {
                        // TODO: recusion might be bad...
                        return this.nextItem();
                    }
                    catch (e) {
                        throw e;
                    }
                }
                else {
                    throw err;
                }
            }
        });
    }
    _createPipelinedExecutionContext(partitionedExecutionInfo) {
        if (!this.resourceLink) {
            throw new Error("for top/orderby resourceLink is required");
        }
        if (Array.isArray(this.resourceLink) && this.resourceLink.length !== 1) {
            throw new Error("for top/orderby exactly one collectionLink is required");
        }
        const collectionLink = Array.isArray(this.resourceLink) ? this.resourceLink[0] : this.resourceLink;
        return new _1.PipelinedQueryExecutionContext(this.clientContext, collectionLink, this.query, this.options, partitionedExecutionInfo);
    }
    /**
     * Retrieve the current element on the ProxyQueryExecutionContext.
     * @memberof ProxyQueryExecutionContext
     * @instance
     * @param {callback} callback - Function to execute for the current element. \
     * the function takes two parameters error, element.
     */
    current() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.queryExecutionContext.current();
            }
            catch (err) {
                if (this._hasPartitionedExecutionInfo(err)) {
                    // if this's a partitioned execution info switches the execution context
                    const partitionedExecutionInfo = this._getParitionedExecutionInfo(err);
                    this.queryExecutionContext = this._createPipelinedExecutionContext(partitionedExecutionInfo);
                    // TODO: recursion
                    try {
                        return this.current();
                    }
                    catch (e) {
                        throw e;
                    }
                }
                else {
                    throw err;
                }
            }
        });
    }
    /**
     * Determine if there are still remaining resources to process.
     * @memberof ProxyQueryExecutionContext
     * @instance
     * @returns {Boolean} true if there is other elements to process in the ProxyQueryExecutionContext.
     */
    hasMoreResults() {
        return this.queryExecutionContext.hasMoreResults();
    }
    fetchMore() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.queryExecutionContext.fetchMore();
            }
            catch (err) {
                if (this._hasPartitionedExecutionInfo(err)) {
                    // if this's a partitioned execution info switches the execution context
                    const partitionedExecutionInfo = this._getParitionedExecutionInfo(err);
                    this.queryExecutionContext = this._createPipelinedExecutionContext(partitionedExecutionInfo);
                    try {
                        // TODO: maybe should move the others to use this pattern as it avoid the recursion issue.
                        return this.queryExecutionContext.fetchMore();
                    }
                    catch (e) {
                        throw e;
                    }
                }
                else {
                    throw err;
                }
            }
        });
    }
    _hasPartitionedExecutionInfo(error) {
        // TODO: any error
        return (error.code === common_1.StatusCodes.BadRequest &&
            "substatus" in error &&
            error["substatus"] === common_1.SubStatusCodes.CrossPartitionQueryNotServable);
    }
    _getParitionedExecutionInfo(error) {
        // TODO: any error
        return JSON.parse(JSON.parse(error.body).additionalErrorInfo);
    }
}
exports.ProxyQueryExecutionContext = ProxyQueryExecutionContext;
//# sourceMappingURL=proxyQueryExecutionContext.js.map