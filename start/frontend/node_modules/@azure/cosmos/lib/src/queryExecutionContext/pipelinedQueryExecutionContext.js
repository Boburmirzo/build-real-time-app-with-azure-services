"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const _1 = require(".");
const EndpointComponent_1 = require("./EndpointComponent");
/** @hidden */
class PipelinedQueryExecutionContext {
    constructor(clientContext, collectionLink, query, // TODO: any query
    options, // TODO: any options
    partitionedQueryExecutionInfo) {
        this.clientContext = clientContext;
        this.collectionLink = collectionLink;
        this.query = query;
        this.options = options;
        this.partitionedQueryExecutionInfo = partitionedQueryExecutionInfo;
        this.endpoint = null;
        this.pageSize = options["maxItemCount"];
        if (this.pageSize === undefined) {
            this.pageSize = PipelinedQueryExecutionContext.DEFAULT_PAGE_SIZE;
        }
        // Pick between parallel vs order by execution context
        const sortOrders = _1.PartitionedQueryExecutionContextInfoParser.parseOrderBy(partitionedQueryExecutionInfo);
        if (Array.isArray(sortOrders) && sortOrders.length > 0) {
            // Need to wrap orderby execution context in endpoint component, since the data is nested as a \
            //      "payload" property.
            this.endpoint = new EndpointComponent_1.OrderByEndpointComponent(new _1.OrderByQueryExecutionContext(this.clientContext, this.collectionLink, this.query, this.options, this.partitionedQueryExecutionInfo));
        }
        else {
            this.endpoint = new _1.ParallelQueryExecutionContext(this.clientContext, this.collectionLink, this.query, this.options, this.partitionedQueryExecutionInfo);
        }
        // If aggregate then add that to the pipeline
        const aggregates = _1.PartitionedQueryExecutionContextInfoParser.parseAggregates(partitionedQueryExecutionInfo);
        if (Array.isArray(aggregates) && aggregates.length > 0) {
            this.endpoint = new EndpointComponent_1.AggregateEndpointComponent(this.endpoint, aggregates);
        }
        // If top then add that to the pipeline
        const top = _1.PartitionedQueryExecutionContextInfoParser.parseTop(partitionedQueryExecutionInfo);
        if (typeof top === "number") {
            this.endpoint = new EndpointComponent_1.TopEndpointComponent(this.endpoint, top);
        }
    }
    nextItem() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.endpoint.nextItem();
        });
    }
    current() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.endpoint.current();
        });
    }
    // Removed callback here beacuse it wouldn't have ever worked...
    hasMoreResults() {
        return this.endpoint.hasMoreResults();
    }
    fetchMore() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // if the wrapped endpoint has different implementation for fetchMore use that
            // otherwise use the default implementation
            if (typeof this.endpoint.fetchMore === "function") {
                return this.endpoint.fetchMore();
            }
            else {
                this.fetchBuffer = [];
                this.fetchMoreRespHeaders = _1.HeaderUtils.getInitialHeader();
                return this._fetchMoreImplementation();
            }
        });
    }
    _fetchMoreImplementation() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { result: item, headers } = yield this.endpoint.nextItem();
                _1.HeaderUtils.mergeHeaders(this.fetchMoreRespHeaders, headers);
                if (item === undefined) {
                    // no more results
                    if (this.fetchBuffer.length === 0) {
                        return {
                            result: undefined,
                            headers: this.fetchMoreRespHeaders
                        };
                    }
                    else {
                        // Just give what we have
                        const temp = this.fetchBuffer;
                        this.fetchBuffer = [];
                        return { result: temp, headers: this.fetchMoreRespHeaders };
                    }
                }
                else {
                    // append the result
                    this.fetchBuffer.push(item);
                    if (this.fetchBuffer.length >= this.pageSize) {
                        // fetched enough results
                        const temp = this.fetchBuffer.slice(0, this.pageSize);
                        this.fetchBuffer = this.fetchBuffer.splice(this.pageSize);
                        return { result: temp, headers: this.fetchMoreRespHeaders };
                    }
                    else {
                        // recursively fetch more
                        // TODO: is recursion a good idea?
                        return this._fetchMoreImplementation();
                    }
                }
            }
            catch (err) {
                _1.HeaderUtils.mergeHeaders(this.fetchMoreRespHeaders, err.headers);
                err.headers = this.fetchMoreRespHeaders;
                if (err) {
                    throw err;
                }
            }
        });
    }
}
PipelinedQueryExecutionContext.DEFAULT_PAGE_SIZE = 10;
exports.PipelinedQueryExecutionContext = PipelinedQueryExecutionContext;
//# sourceMappingURL=pipelinedQueryExecutionContext.js.map