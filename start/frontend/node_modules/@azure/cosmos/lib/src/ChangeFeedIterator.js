"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ChangeFeedResponse_1 = require("./ChangeFeedResponse");
const common_1 = require("./common");
/**
 * Provides iterator for change feed.
 *
 * Use `Items.readChangeFeed()` to get an instance of the iterator.
 */
class ChangeFeedIterator {
    /**
     * @internal
     * @hidden
     *
     * @param clientContext
     * @param resourceId
     * @param resourceLink
     * @param isPartitionedContainer
     * @param changeFeedOptions
     */
    constructor(clientContext, resourceId, resourceLink, partitionKey, isPartitionedContainer, changeFeedOptions) {
        this.clientContext = clientContext;
        this.resourceId = resourceId;
        this.resourceLink = resourceLink;
        this.partitionKey = partitionKey;
        this.isPartitionedContainer = isPartitionedContainer;
        this.changeFeedOptions = changeFeedOptions;
        // partition key XOR partition key range id
        const partitionKeyValid = partitionKey !== undefined;
        this.isPartitionSpecified = partitionKeyValid;
        let canUseStartFromBeginning = true;
        if (changeFeedOptions.continuation) {
            this.nextIfNoneMatch = changeFeedOptions.continuation;
            canUseStartFromBeginning = false;
        }
        if (changeFeedOptions.startTime) {
            // .toUTCString() is platform specific, but most platforms use RFC 1123.
            // In ECMAScript 2018, this was standardized to RFC 1123.
            // See for more info: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toUTCString
            this.ifModifiedSince = changeFeedOptions.startTime.toUTCString();
            canUseStartFromBeginning = false;
        }
        if (canUseStartFromBeginning && !changeFeedOptions.startFromBeginning) {
            this.nextIfNoneMatch = ChangeFeedIterator.IfNoneMatchAllHeaderValue;
        }
    }
    /**
     * Gets a value indicating whether there are potentially additional results that can be retrieved.
     *
     * Initially returns true. This value is set based on whether the last execution returned a continuation token.
     *
     * @returns Boolean value representing if whether there are potentially additional results that can be retrieved.
     */
    get hasMoreResults() {
        return this.lastStatusCode !== common_1.StatusCodes.NotModified;
    }
    /**
     * Gets an async iterator which will yield pages of results from Azure Cosmos DB.
     */
    getAsyncIterator() {
        return tslib_1.__asyncGenerator(this, arguments, function* getAsyncIterator_1() {
            do {
                const result = yield tslib_1.__await(this.executeNext());
                if (result.count > 0) {
                    yield yield tslib_1.__await(result);
                }
            } while (this.hasMoreResults);
        });
    }
    /**
     * Read feed and retrieves the next page of results in Azure Cosmos DB.
     */
    executeNext() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.getFeedResponse();
            this.lastStatusCode = response.statusCode;
            this.nextIfNoneMatch = response.headers[common_1.Constants.HttpHeaders.ETag];
            return response;
        });
    }
    getFeedResponse() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const isParittionedContainer = yield this.isPartitionedContainer();
            if (!this.isPartitionSpecified && isParittionedContainer) {
                throw new Error("Container is partitioned, but no partition key or partition key range id was specified.");
            }
            const feedOptions = { initialHeaders: {}, a_im: "Incremental feed" };
            if (typeof this.changeFeedOptions.maxItemCount === "number") {
                feedOptions.maxItemCount = this.changeFeedOptions.maxItemCount;
            }
            if (this.changeFeedOptions.sessionToken) {
                feedOptions.sessionToken = this.changeFeedOptions.sessionToken;
            }
            if (this.nextIfNoneMatch) {
                feedOptions.accessCondition = {
                    type: common_1.Constants.HttpHeaders.IfNoneMatch,
                    condition: this.nextIfNoneMatch
                };
            }
            if (this.ifModifiedSince) {
                feedOptions.initialHeaders[common_1.Constants.HttpHeaders.IfModifiedSince] = this.ifModifiedSince;
            }
            if (this.partitionKey !== undefined) {
                feedOptions.partitionKey = this.partitionKey; // TODO: our partition key is too restrictive on the main object
            }
            const response = yield this.clientContext.queryFeed(this.resourceLink, common_1.ResourceType.item, this.resourceId, result => (result ? result.Documents : []), undefined, feedOptions); // TODO: some funky issues with query feed. Probably need to change it up.
            return new ChangeFeedResponse_1.ChangeFeedResponse(response.result, response.result ? response.result.length : 0, response.statusCode, response.headers);
        });
    }
}
ChangeFeedIterator.IfNoneMatchAllHeaderValue = "*";
exports.ChangeFeedIterator = ChangeFeedIterator;
//# sourceMappingURL=ChangeFeedIterator.js.map