"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** @hidden */
class Range {
    /**
     * Represents a range object used by the RangePartitionResolver in the Azure Cosmos DB database service.
     * @class Range
     * @param {object} options                   - The Range constructor options.
     * @param {any} options.low                  - The low value in the range.
     * @param {any} options.high                 - The high value in the range.
     */
    constructor(options) {
        // TODO: This is an alias for backwards compatibility. Need to decide if this is public surface area or not
        // tslint:disable-next-line:variable-name
        this._contains = this.contains;
        // TODO: alias for backwards compat
        // tslint:disable-next-line:variable-name
        this._intersect = this.intersect;
        // TODO: alias for backwards compat
        // tslint:disable-next-line:variable-name
        this._toString = this.toString;
        // TODO: any options
        if (options === undefined) {
            options = {};
        }
        if (options === null) {
            throw new Error("Invalid argument: 'options' is null");
        }
        if (typeof options !== "object") {
            throw new Error("Invalid argument: 'options' is not an object");
        }
        if (options.high === undefined) {
            options.high = options.low;
        }
        this.low = options.low;
        this.high = options.high;
        Object.freeze(this);
    }
    // TODO: private?
    _compare(x, y, compareFunction) {
        // Same semantics as Array.sort
        // http://www.ecma-international.org/ecma-262/6.0/#sec-sortcompare
        if (x === undefined && y === undefined) {
            return 0;
        }
        if (x === undefined) {
            return 1;
        }
        if (y === undefined) {
            return -1;
        }
        if (compareFunction !== undefined) {
            const v = Number(compareFunction(x, y));
            if (Number.isNaN(v)) {
                return 0;
            }
            return v;
        }
        const xString = String(x);
        const yString = String(y);
        if (xString < yString) {
            return -1;
        }
        if (xString > yString) {
            return 1;
        }
        return 0;
    }
    contains(other, compareFunction) {
        if (Range.isRange(other)) {
            return this._containsRange(other, compareFunction);
        }
        else {
            return this._containsPoint(other, compareFunction);
        }
    }
    // TODO: private?
    _containsPoint(point, compareFunction) {
        return (this._compare(point, this.low, compareFunction) >= 0 && this._compare(point, this.high, compareFunction) <= 0);
    }
    // TODO: private?
    _containsRange(range, compareFunction) {
        return (this._compare(range.low, this.low, compareFunction) >= 0 &&
            this._compare(range.high, this.high, compareFunction) <= 0);
    }
    intersect(range, compareFunction) {
        if (range === undefined || range === null) {
            throw new Error("Invalid Argument: 'other' is undefined or null");
        }
        const maxLow = this._compare(this.low, range.low, compareFunction) >= 0 ? this.low : range.low;
        const minHigh = this._compare(this.high, range.high, compareFunction) <= 0 ? this.high : range.high;
        return this._compare(maxLow, minHigh, compareFunction) <= 0;
    }
    toString() {
        return String(this.low) + "," + String(this.high);
    }
    static isRange(pointOrRange) {
        if (pointOrRange === undefined) {
            return false;
        }
        if (pointOrRange === null) {
            return false;
        }
        if (typeof pointOrRange !== "object") {
            return false;
        }
        return pointOrRange instanceof Range;
    }
}
// TODO: alias for backwards compat
// tslint:disable-next-line:variable-name
Range._isRange = Range.isRange;
exports.Range = Range;
//# sourceMappingURL=Range.js.map