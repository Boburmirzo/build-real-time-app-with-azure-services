"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const https = tslib_1.__importStar(require("https")); // TYPES ONLY
const url = tslib_1.__importStar(require("url"));
const common_1 = require("../common");
const documents_1 = require("../documents");
const auth_1 = require("../auth");
// ----------------------------------------------------------------------------
// Utility methods
//
/** @hidden */
function javaScriptFriendlyJSONStringify(s) {
    // two line terminators (Line separator and Paragraph separator) are not needed to be escaped in JSON
    // but are needed to be escaped in JavaScript.
    return JSON.stringify(s)
        .replace(/\u2028/g, "\\u2028")
        .replace(/\u2029/g, "\\u2029");
}
/** @hidden */
function bodyFromData(data) {
    if (data.pipe) {
        return data;
    }
    if (Buffer.isBuffer(data)) {
        return data;
    }
    if (typeof data === "string") {
        return data;
    }
    if (typeof data === "object") {
        return javaScriptFriendlyJSONStringify(data);
    }
    return undefined;
}
exports.bodyFromData = bodyFromData;
/** @hidden */
function parse(urlString) {
    return url.parse(urlString);
}
exports.parse = parse;
/** @hidden */
function createRequestObject(connectionPolicy, requestOptions, body) {
    return new Promise((resolve, reject) => {
        function onTimeout() {
            httpsRequest.abort();
        }
        const isMedia = requestOptions.path.indexOf("//media") === 0;
        const httpsRequest = https.request(requestOptions, (response) => {
            // In case of media response, return the stream to the user and the user will need
            // to handle reading the stream.
            if (isMedia && connectionPolicy.MediaReadMode === documents_1.MediaReadMode.Streamed) {
                return resolve({
                    result: response,
                    headers: response.headers
                });
            }
            let data = "";
            // if the requested data is text (not attachment/media) set the encoding to UTF-8
            if (!isMedia) {
                response.setEncoding("utf8");
            }
            response.on("data", chunk => {
                data += chunk;
            });
            response.on("end", () => {
                if (response.statusCode >= 400) {
                    return reject(getErrorBody(response, data, response.headers));
                }
                let result;
                try {
                    result = isMedia ? data : data.length > 0 ? JSON.parse(data) : undefined;
                }
                catch (exception) {
                    return reject(exception);
                }
                resolve({ result, headers: response.headers, statusCode: response.statusCode });
            });
        });
        httpsRequest.once("socket", (socket) => {
            if (isMedia) {
                socket.setTimeout(connectionPolicy.MediaRequestTimeout);
            }
            else {
                socket.setTimeout(connectionPolicy.RequestTimeout);
            }
            socket.once("timeout", onTimeout);
            httpsRequest.once("response", () => {
                socket.removeListener("timeout", onTimeout);
            });
        });
        httpsRequest.once("error", reject);
        if (body) {
            httpsRequest.write(body);
            httpsRequest.end();
        }
        else {
            httpsRequest.end();
        }
    });
}
exports.createRequestObject = createRequestObject;
/**
 *  Constructs the error body from the response and the data returned from the request.
 * @param {object} response - response object returned from the executon of a request.
 * @param {object} data - the data body returned from the executon of a request.
 * @hidden
 */
function getErrorBody(response, data, headers) {
    const errorBody = {
        code: response.statusCode,
        body: data,
        headers
    };
    if (common_1.Constants.HttpHeaders.ActivityId in response.headers) {
        errorBody.activityId = response.headers[common_1.Constants.HttpHeaders.ActivityId];
    }
    if (common_1.Constants.HttpHeaders.SubStatus in response.headers) {
        errorBody.substatus = parseInt(response.headers[common_1.Constants.HttpHeaders.SubStatus], 10);
    }
    if (common_1.Constants.HttpHeaders.RetryAfterInMilliseconds in response.headers) {
        errorBody.retryAfterInMilliseconds = parseInt(response.headers[common_1.Constants.HttpHeaders.RetryAfterInMilliseconds], 10);
    }
    return errorBody;
}
function getHeaders(authOptions, defaultHeaders, verb, path, resourceId, resourceType, options, partitionKeyRangeId, useMultipleWriteLocations) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const headers = Object.assign({}, defaultHeaders);
        const opts = (options || {}); // TODO: this is dirty
        if (useMultipleWriteLocations) {
            headers[common_1.Constants.HttpHeaders.ALLOW_MULTIPLE_WRITES] = true;
        }
        if (opts.continuation) {
            headers[common_1.Constants.HttpHeaders.Continuation] = opts.continuation;
        }
        if (opts.preTriggerInclude) {
            headers[common_1.Constants.HttpHeaders.PreTriggerInclude] =
                opts.preTriggerInclude.constructor === Array
                    ? opts.preTriggerInclude.join(",")
                    : opts.preTriggerInclude;
        }
        if (opts.postTriggerInclude) {
            headers[common_1.Constants.HttpHeaders.PostTriggerInclude] =
                opts.postTriggerInclude.constructor === Array
                    ? opts.postTriggerInclude.join(",")
                    : opts.postTriggerInclude;
        }
        if (opts.offerType) {
            headers[common_1.Constants.HttpHeaders.OfferType] = opts.offerType;
        }
        if (opts.offerThroughput) {
            headers[common_1.Constants.HttpHeaders.OfferThroughput] = opts.offerThroughput;
        }
        if (opts.maxItemCount) {
            headers[common_1.Constants.HttpHeaders.PageSize] = opts.maxItemCount;
        }
        if (opts.accessCondition) {
            if (opts.accessCondition.type === "IfMatch") {
                headers[common_1.Constants.HttpHeaders.IfMatch] = opts.accessCondition.condition;
            }
            else {
                headers[common_1.Constants.HttpHeaders.IfNoneMatch] = opts.accessCondition.condition;
            }
        }
        if (opts.a_im) {
            headers[common_1.Constants.HttpHeaders.A_IM] = opts.a_im;
        }
        if (opts.indexingDirective) {
            headers[common_1.Constants.HttpHeaders.IndexingDirective] = opts.indexingDirective;
        }
        if (opts.consistencyLevel) {
            headers[common_1.Constants.HttpHeaders.ConsistencyLevel] = opts.consistencyLevel;
        }
        if (opts.resourceTokenExpirySeconds) {
            headers[common_1.Constants.HttpHeaders.ResourceTokenExpiry] = opts.resourceTokenExpirySeconds;
        }
        if (opts.sessionToken) {
            headers[common_1.Constants.HttpHeaders.SessionToken] = opts.sessionToken;
        }
        if (opts.enableScanInQuery) {
            headers[common_1.Constants.HttpHeaders.EnableScanInQuery] = opts.enableScanInQuery;
        }
        if (opts.enableCrossPartitionQuery) {
            headers[common_1.Constants.HttpHeaders.EnableCrossPartitionQuery] = opts.enableCrossPartitionQuery;
        }
        if (opts.populateQuotaInfo) {
            headers[common_1.Constants.HttpHeaders.PopulateQuotaInfo] = opts.populateQuotaInfo;
        }
        if (opts.populateQueryMetrics) {
            headers[common_1.Constants.HttpHeaders.PopulateQueryMetrics] = opts.populateQueryMetrics;
        }
        if (opts.maxDegreeOfParallelism !== undefined) {
            headers[common_1.Constants.HttpHeaders.ParallelizeCrossPartitionQuery] = true;
        }
        if (opts.populateQuotaInfo) {
            headers[common_1.Constants.HttpHeaders.PopulateQuotaInfo] = true;
        }
        if (opts.partitionKey !== undefined) {
            let partitionKey = opts.partitionKey;
            if (partitionKey === null || !Array.isArray(partitionKey)) {
                partitionKey = [partitionKey];
            }
            headers[common_1.Constants.HttpHeaders.PartitionKey] = common_1.Helper.jsonStringifyAndEscapeNonASCII(partitionKey);
        }
        if (authOptions.masterKey || authOptions.key || authOptions.tokenProvider) {
            headers[common_1.Constants.HttpHeaders.XDate] = new Date().toUTCString();
        }
        if (verb === "post" || verb === "put") {
            if (!headers[common_1.Constants.HttpHeaders.ContentType]) {
                headers[common_1.Constants.HttpHeaders.ContentType] = common_1.Constants.MediaTypes.Json;
            }
        }
        if (!headers[common_1.Constants.HttpHeaders.Accept]) {
            headers[common_1.Constants.HttpHeaders.Accept] = common_1.Constants.MediaTypes.Json;
        }
        if (partitionKeyRangeId !== undefined) {
            headers[common_1.Constants.HttpHeaders.PartitionKeyRangeID] = partitionKeyRangeId;
        }
        if (opts.enableScriptLogging) {
            headers[common_1.Constants.HttpHeaders.EnableScriptLogging] = opts.enableScriptLogging;
        }
        if (opts.offerEnableRUPerMinuteThroughput) {
            headers[common_1.Constants.HttpHeaders.OfferIsRUPerMinuteThroughputEnabled] = true;
        }
        if (opts.disableRUPerMinuteUsage) {
            headers[common_1.Constants.HttpHeaders.DisableRUPerMinuteUsage] = true;
        }
        if (authOptions.masterKey ||
            authOptions.key ||
            authOptions.resourceTokens ||
            authOptions.tokenProvider ||
            authOptions.permissionFeed) {
            const token = yield auth_1.AuthHandler.getAuthorizationHeader(authOptions, verb, path, resourceId, resourceType, headers);
            headers[common_1.Constants.HttpHeaders.Authorization] = token;
        }
        return headers;
    });
}
exports.getHeaders = getHeaders;
//# sourceMappingURL=request.js.map