"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const https_1 = require("https");
const tunnel = tslib_1.__importStar(require("tunnel"));
const url = tslib_1.__importStar(require("url"));
const _1 = require(".");
const Database_1 = require("./client/Database");
const Offer_1 = require("./client/Offer");
const ClientContext_1 = require("./ClientContext");
const common_1 = require("./common");
const globalEndpointManager_1 = require("./globalEndpointManager");
/**
 * Provides a client-side logical representation of the Azure Cosmos DB database account.
 * This client is used to configure and execute requests in the Azure Cosmos DB database service.
 * @example Instantiate a client and create a new database
 * ```typescript
 * const client = new CosmosClient({endpoint: "<URL HERE>", auth: {masterKey: "<KEY HERE>"}});
 * await client.databases.create({id: "<datbase name here>"});
 * ```
 * @example Instantiate a client with custom Connection Policy
 * ```typescript
 * const connectionPolicy = new ConnectionPolicy();
 * connectionPolicy.RequestTimeout = 10000;
 * const client = new CosmosClient({
 *    endpoint: "<URL HERE>",
 *    auth: {masterKey: "<KEY HERE>"},
 *    connectionPolicy
 * });
 * ```
 */
class CosmosClient {
    constructor(options) {
        this.options = options;
        options.auth = options.auth || {};
        if (options.key) {
            options.auth.key = options.key;
        }
        options.connectionPolicy = common_1.Helper.parseConnectionPolicy(options.connectionPolicy);
        options.defaultHeaders = options.defaultHeaders || {};
        options.defaultHeaders[_1.Constants.HttpHeaders.CacheControl] = "no-cache";
        options.defaultHeaders[_1.Constants.HttpHeaders.Version] = _1.Constants.CurrentVersion;
        if (options.consistencyLevel !== undefined) {
            options.defaultHeaders[_1.Constants.HttpHeaders.ConsistencyLevel] = options.consistencyLevel;
        }
        const platformDefaultHeaders = common_1.Platform.getPlatformDefaultHeaders() || {};
        for (const platformDefaultHeader of Object.keys(platformDefaultHeaders)) {
            options.defaultHeaders[platformDefaultHeader] = platformDefaultHeaders[platformDefaultHeader];
        }
        options.defaultHeaders[_1.Constants.HttpHeaders.UserAgent] = common_1.Platform.getUserAgent();
        if (!this.options.agent) {
            // Initialize request agent
            const requestAgentOptions = {
                keepAlive: true,
                maxSockets: 256,
                maxFreeSockets: 256
            };
            if (!!this.options.connectionPolicy.ProxyUrl) {
                const proxyUrl = url.parse(this.options.connectionPolicy.ProxyUrl);
                const port = parseInt(proxyUrl.port, 10);
                requestAgentOptions.proxy = {
                    host: proxyUrl.hostname,
                    port,
                    headers: {}
                };
                if (!!proxyUrl.auth) {
                    requestAgentOptions.proxy.proxyAuth = proxyUrl.auth;
                }
                this.options.agent =
                    proxyUrl.protocol.toLowerCase() === "https:"
                        ? tunnel.httpsOverHttps(requestAgentOptions)
                        : tunnel.httpsOverHttp(requestAgentOptions); // TODO: type coersion
            }
            else {
                this.options.agent = new https_1.Agent(requestAgentOptions); // TODO: Move to request?
            }
        }
        const globalEndpointManager = new globalEndpointManager_1.GlobalEndpointManager(this.options, (opts) => tslib_1.__awaiter(this, void 0, void 0, function* () { return this.getDatabaseAccount(opts); }));
        this.clientContext = new ClientContext_1.ClientContext(options, globalEndpointManager);
        this.databases = new Database_1.Databases(this, this.clientContext);
        this.offers = new Offer_1.Offers(this, this.clientContext);
    }
    /**
     * Get information about the current {@link DatabaseAccount} (including which regions are supported, etc.)
     */
    getDatabaseAccount(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.clientContext.getDatabaseAccount(options);
            return { body: response.result, headers: response.headers, ref: this };
        });
    }
    /**
     * Gets the currently used write endpoint url. Useful for troubleshooting purposes.
     *
     * The url may contain a region suffix (e.g. "-eastus") if we're using location specific endpoints.
     */
    getWriteEndpoint() {
        return this.clientContext.getWriteEndpoint();
    }
    /**
     * Gets the currently used read endpoint. Useful for troubleshooting purposes.
     *
     * The url may contain a region suffix (e.g. "-eastus") if we're using location specific endpoints.
     */
    getReadEndpoint() {
        return this.clientContext.getReadEndpoint();
    }
    /**
     * Used for reading, updating, or deleting a existing database by id or accessing containers belonging to that database.
     *
     * This does not make a network call. Use `.read` to get info about the database after getting the {@link Database} object.
     *
     * @param id The id of the database.
     * @example Create a new container off of an existing database
     * ```typescript
     * const container = client.database("<database id>").containers.create("<container id>");
     * ```
     *
     * @example Delete an existing database
     * ```typescript
     * await client.database("<id here>").delete();
     * ```
     */
    database(id) {
        return new Database_1.Database(this, id, this.clientContext);
    }
    /**
     * Used for reading, or updating a existing offer by id.
     * @param id The id of the offer.
     */
    offer(id) {
        return new Offer_1.Offer(this, id, this.clientContext);
    }
}
exports.CosmosClient = CosmosClient;
//# sourceMappingURL=CosmosClient.js.map