import { PartitionKey } from "../..";
import { ClientContext } from "../../ClientContext";
import { PartitionKeyDefinition } from "../../documents";
import { CosmosResponse, FeedOptions, RequestOptions } from "../../request";
import { Conflict, Conflicts } from "../Conflict";
import { Database } from "../Database";
import { Item, Items } from "../Item";
import { StoredProcedure, StoredProcedures } from "../StoredProcedure";
import { Trigger, Triggers } from "../Trigger";
import { UserDefinedFunction, UserDefinedFunctions } from "../UserDefinedFunction";
import { ContainerDefinition } from "./ContainerDefinition";
import { ContainerResponse } from "./ContainerResponse";
/**
 * Operations for reading, replacing, or deleting a specific, existing container by id.
 *
 * @see {@link Containers} for creating new containers, and reading/querying all containers; use `.containers`.
 *
 * Note: all these operations make calls against a fixed budget.
 * You should design your system such that these calls scale sublinearly with your application.
 * For instance, do not call `container(id).read()` before every single `item.read()` call, to ensure the container exists;
 * do this once on application start up.
 */
export declare class Container {
    readonly database: Database;
    readonly id: string;
    private readonly clientContext;
    /**
     * Operations for creating new items, and reading/querying all items
     *
     * For reading, replacing, or deleting an existing item, use `.item(id)`.
     *
     * @example Create a new item
     * ```typescript
     * const {body: createdItem} = await container.items.create({id: "<item id>", properties: {}});
     * ```
     */
    readonly items: Items;
    /**
     * Operations for creating new stored procedures, and reading/querying all stored procedures.
     *
     * For reading, replacing, or deleting an existing stored procedure, use `.storedProcedure(id)`.
     */
    readonly storedProcedures: StoredProcedures;
    /**
     * Operations for creating new triggers, and reading/querying all triggers.
     *
     * For reading, replacing, or deleting an existing trigger, use `.trigger(id)`.
     */
    readonly triggers: Triggers;
    /**
     * Operations for creating new user defined functions, and reading/querying all user defined functions.
     *
     * For reading, replacing, or deleting an existing user defined function, use `.userDefinedFunction(id)`.
     */
    readonly userDefinedFunctions: UserDefinedFunctions;
    readonly conflicts: Conflicts;
    /**
     * Returns a reference URL to the resource. Used for linking in Permissions.
     */
    readonly url: string;
    /**
     * Returns a container instance. Note: You should get this from `database.container(id)`, rather than creating your own object.
     * @param database The parent {@link Database}.
     * @param id The id of the given container.
     * @hidden
     */
    constructor(database: Database, id: string, clientContext: ClientContext);
    /**
     * Used to read, replace, or delete a specific, existing {@link Item} by id.
     *
     * Use `.items` for creating new items, or querying/reading all items.
     *
     * @param id The id of the {@link Item}.
     * @param partitionKey The partition key of the {@link Item}. (Required for partitioned containers).
     * @example Replace an item
     * const {body: replacedItem} = await container.item("<item id>").replace({id: "<item id>", title: "Updated post", authorID: 5});
     */
    item(id: string, partitionKey?: string): Item;
    /**
     * Used to read, replace, or delete a specific, existing {@link UserDefinedFunction} by id.
     *
     * Use `.userDefinedFunctions` for creating new user defined functions, or querying/reading all user defined functions.
     * @param id The id of the {@link UserDefinedFunction}.
     */
    userDefinedFunction(id: string): UserDefinedFunction;
    /**
     * Used to read, replace, or delete a specific, existing {@link Conflict} by id.
     *
     * Use `.conflicts` for creating new conflicts, or querying/reading all conflicts.
     * @param id The id of the {@link Conflict}.
     */
    conflict(id: string): Conflict;
    /**
     * Used to read, replace, or delete a specific, existing {@link StoredProcedure} by id.
     *
     * Use `.storedProcedures` for creating new stored procedures, or querying/reading all stored procedures.
     * @param id The id of the {@link StoredProcedure}.
     */
    storedProcedure(id: string): StoredProcedure;
    /**
     * Used to read, replace, or delete a specific, existing {@link Trigger} by id.
     *
     * Use `.triggers` for creating new triggers, or querying/reading all triggers.
     * @param id The id of the {@link Trigger}.
     */
    trigger(id: string): Trigger;
    /** Read the container's definition */
    read(options?: RequestOptions): Promise<ContainerResponse>;
    /** Replace the container's definition */
    replace(body: ContainerDefinition, options?: RequestOptions): Promise<ContainerResponse>;
    /** Delete the container */
    delete(options?: RequestOptions): Promise<ContainerResponse>;
    /**
     * Gets the partition key definition first by looking into the cache otherwise by reading the collection.
     * @ignore
     * @param {string} collectionLink   - Link to the collection whose partition key needs to be extracted.
     * @param {function} callback       - \
     * The arguments to the callback are(in order): error, partitionKeyDefinition, response object and response headers
     */
    getPartitionKeyDefinition(): Promise<CosmosResponse<PartitionKeyDefinition, Container>>;
    readPartitionKeyRanges(feedOptions?: FeedOptions): import("../../queryIterator").QueryIterator<import("./PartitionKeyRange").PartitionKeyRange>;
    extractPartitionKey(document: any, partitionKeyDefinition: PartitionKeyDefinition): PartitionKey[];
}
