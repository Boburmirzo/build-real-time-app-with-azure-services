"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const common_1 = require("../../common");
const Conflict_1 = require("../Conflict");
const Item_1 = require("../Item");
const StoredProcedure_1 = require("../StoredProcedure");
const Trigger_1 = require("../Trigger");
const UserDefinedFunction_1 = require("../UserDefinedFunction");
/**
 * Operations for reading, replacing, or deleting a specific, existing container by id.
 *
 * @see {@link Containers} for creating new containers, and reading/querying all containers; use `.containers`.
 *
 * Note: all these operations make calls against a fixed budget.
 * You should design your system such that these calls scale sublinearly with your application.
 * For instance, do not call `container(id).read()` before every single `item.read()` call, to ensure the container exists;
 * do this once on application start up.
 */
class Container {
    /**
     * Returns a container instance. Note: You should get this from `database.container(id)`, rather than creating your own object.
     * @param database The parent {@link Database}.
     * @param id The id of the given container.
     * @hidden
     */
    constructor(database, id, clientContext) {
        this.database = database;
        this.id = id;
        this.clientContext = clientContext;
        this.items = new Item_1.Items(this, this.clientContext);
        this.storedProcedures = new StoredProcedure_1.StoredProcedures(this, this.clientContext);
        this.triggers = new Trigger_1.Triggers(this, this.clientContext);
        this.userDefinedFunctions = new UserDefinedFunction_1.UserDefinedFunctions(this, this.clientContext);
        this.conflicts = new Conflict_1.Conflicts(this, this.clientContext);
    }
    /**
     * Returns a reference URL to the resource. Used for linking in Permissions.
     */
    get url() {
        return common_1.UriFactory.createDocumentCollectionUri(this.database.id, this.id);
    }
    /**
     * Used to read, replace, or delete a specific, existing {@link Item} by id.
     *
     * Use `.items` for creating new items, or querying/reading all items.
     *
     * @param id The id of the {@link Item}.
     * @param partitionKey The partition key of the {@link Item}. (Required for partitioned containers).
     * @example Replace an item
     * const {body: replacedItem} = await container.item("<item id>").replace({id: "<item id>", title: "Updated post", authorID: 5});
     */
    item(id, partitionKey) {
        return new Item_1.Item(this, id, partitionKey, this.clientContext);
    }
    /**
     * Used to read, replace, or delete a specific, existing {@link UserDefinedFunction} by id.
     *
     * Use `.userDefinedFunctions` for creating new user defined functions, or querying/reading all user defined functions.
     * @param id The id of the {@link UserDefinedFunction}.
     */
    userDefinedFunction(id) {
        return new UserDefinedFunction_1.UserDefinedFunction(this, id, this.clientContext);
    }
    /**
     * Used to read, replace, or delete a specific, existing {@link Conflict} by id.
     *
     * Use `.conflicts` for creating new conflicts, or querying/reading all conflicts.
     * @param id The id of the {@link Conflict}.
     */
    conflict(id) {
        return new Conflict_1.Conflict(this, id, this.clientContext);
    }
    /**
     * Used to read, replace, or delete a specific, existing {@link StoredProcedure} by id.
     *
     * Use `.storedProcedures` for creating new stored procedures, or querying/reading all stored procedures.
     * @param id The id of the {@link StoredProcedure}.
     */
    storedProcedure(id) {
        return new StoredProcedure_1.StoredProcedure(this, id, this.clientContext);
    }
    /**
     * Used to read, replace, or delete a specific, existing {@link Trigger} by id.
     *
     * Use `.triggers` for creating new triggers, or querying/reading all triggers.
     * @param id The id of the {@link Trigger}.
     */
    trigger(id) {
        return new Trigger_1.Trigger(this, id, this.clientContext);
    }
    /** Read the container's definition */
    read(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const path = common_1.Helper.getPathFromLink(this.url);
            const id = common_1.Helper.getIdFromLink(this.url);
            const response = yield this.clientContext.read(path, "colls", id, undefined, options);
            this.clientContext.partitionKeyDefinitionCache[this.url] = response.result.partitionKey;
            return {
                body: response.result,
                headers: response.headers,
                ref: this,
                container: this
            };
        });
    }
    /** Replace the container's definition */
    replace(body, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const err = {};
            if (!common_1.Helper.isResourceValid(body, err)) {
                throw err;
            }
            const path = common_1.Helper.getPathFromLink(this.url);
            const id = common_1.Helper.getIdFromLink(this.url);
            const response = yield this.clientContext.replace(body, path, "colls", id, undefined, options);
            return {
                body: response.result,
                headers: response.headers,
                ref: this,
                container: this
            };
        });
    }
    /** Delete the container */
    delete(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const path = common_1.Helper.getPathFromLink(this.url);
            const id = common_1.Helper.getIdFromLink(this.url);
            const response = yield this.clientContext.delete(path, "colls", id, undefined, options);
            return {
                body: response.result,
                headers: response.headers,
                ref: this,
                container: this
            };
        });
    }
    /**
     * Gets the partition key definition first by looking into the cache otherwise by reading the collection.
     * @ignore
     * @param {string} collectionLink   - Link to the collection whose partition key needs to be extracted.
     * @param {function} callback       - \
     * The arguments to the callback are(in order): error, partitionKeyDefinition, response object and response headers
     */
    getPartitionKeyDefinition() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // $ISSUE-felixfan-2016-03-17: Make name based path and link based path use the same key
            // $ISSUE-felixfan-2016-03-17: Refresh partitionKeyDefinitionCache when necessary
            if (this.url in this.clientContext.partitionKeyDefinitionCache) {
                return {
                    body: this.clientContext.partitionKeyDefinitionCache[this.url],
                    ref: this
                };
            }
            const { headers } = yield this.read();
            return {
                body: this.clientContext.partitionKeyDefinitionCache[this.url],
                headers,
                ref: this
            };
        });
    }
    readPartitionKeyRanges(feedOptions) {
        feedOptions = feedOptions || {};
        return this.clientContext.queryPartitionKeyRanges(this.url, undefined, feedOptions);
    }
    // TODO: The ParitionKey type is REALLY weird. Now that it's being exported, we should clean it up.
    extractPartitionKey(document, partitionKeyDefinition) {
        // TODO: any
        if (partitionKeyDefinition && partitionKeyDefinition.paths && partitionKeyDefinition.paths.length > 0) {
            const partitionKey = [];
            partitionKeyDefinition.paths.forEach((path) => {
                const pathParts = common_1.Helper.parsePath(path);
                let obj = document;
                for (const part of pathParts) {
                    if (!(typeof obj === "object" && part in obj)) {
                        obj = {};
                        break;
                    }
                    obj = obj[part];
                }
                partitionKey.push(obj);
            });
            return partitionKey;
        }
        return undefined;
    }
}
exports.Container = Container;
//# sourceMappingURL=Container.js.map