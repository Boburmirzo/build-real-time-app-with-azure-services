"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ChangeFeedIterator_1 = require("../../ChangeFeedIterator");
const common_1 = require("../../common");
const queryIterator_1 = require("../../queryIterator");
const Item_1 = require("./Item");
function isChangeFeedOptions(options) {
    const optionsType = typeof options;
    return options && !(optionsType === "string" || optionsType === "boolean" || optionsType === "number");
}
/**
 * Operations for creating new items, and reading/querying all items
 *
 * @see {@link Item} for reading, replacing, or deleting an existing container; use `.item(id)`.
 */
class Items {
    /**
     * Create an instance of {@link Items} linked to the parent {@link Container}.
     * @param container The parent container.
     * @hidden
     */
    constructor(container, clientContext) {
        this.container = container;
        this.clientContext = clientContext;
    }
    query(query, options) {
        const path = common_1.Helper.getPathFromLink(this.container.url, "docs");
        const id = common_1.Helper.getIdFromLink(this.container.url);
        const fetchFunction = (innerOptions) => {
            return this.clientContext.queryFeed(path, "docs", id, result => (result ? result.Documents : []), query, innerOptions);
        };
        return new queryIterator_1.QueryIterator(this.clientContext, query, options, fetchFunction, this.container.url);
    }
    readChangeFeed(partitionKeyOrChangeFeedOptions, changeFeedOptions) {
        let partitionKey;
        if (!changeFeedOptions && isChangeFeedOptions(partitionKeyOrChangeFeedOptions)) {
            partitionKey = undefined;
            changeFeedOptions = partitionKeyOrChangeFeedOptions;
        }
        else if (partitionKeyOrChangeFeedOptions !== undefined && !isChangeFeedOptions(partitionKeyOrChangeFeedOptions)) {
            partitionKey = partitionKeyOrChangeFeedOptions;
        }
        if (!changeFeedOptions) {
            throw new Error("changeFeedOptions must be a valid object");
        }
        const path = common_1.Helper.getPathFromLink(this.container.url, "docs");
        const id = common_1.Helper.getIdFromLink(this.container.url);
        return new ChangeFeedIterator_1.ChangeFeedIterator(this.clientContext, id, path, partitionKey, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const bodyWillBeTruthyIfPartitioned = (yield this.container.getPartitionKeyDefinition()).body;
            return !!bodyWillBeTruthyIfPartitioned;
        }), changeFeedOptions);
    }
    readAll(options) {
        return this.query(undefined, options);
    }
    create(body, options = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (options.partitionKey === undefined && options.skipGetPartitionKeyDefinition !== true) {
                const { body: partitionKeyDefinition } = yield this.container.getPartitionKeyDefinition();
                options.partitionKey = this.container.extractPartitionKey(body, partitionKeyDefinition);
            }
            // Generate random document id if the id is missing in the payload and
            // options.disableAutomaticIdGeneration != true
            if ((body.id === undefined || body.id === "") && !options.disableAutomaticIdGeneration) {
                body.id = common_1.Helper.generateGuidId();
            }
            const err = {};
            if (!common_1.Helper.isResourceValid(body, err)) {
                throw err;
            }
            const path = common_1.Helper.getPathFromLink(this.container.url, "docs");
            const id = common_1.Helper.getIdFromLink(this.container.url);
            const response = yield this.clientContext.create(body, path, "docs", id, undefined, options);
            const ref = new Item_1.Item(this.container, response.result.id, (options && options.partitionKey), this.clientContext);
            return {
                body: response.result,
                headers: response.headers,
                ref,
                item: ref
            };
        });
    }
    upsert(body, options = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (options.partitionKey === undefined && options.skipGetPartitionKeyDefinition !== true) {
                const { body: partitionKeyDefinition } = yield this.container.getPartitionKeyDefinition();
                options.partitionKey = this.container.extractPartitionKey(body, partitionKeyDefinition);
            }
            // Generate random document id if the id is missing in the payload and
            // options.disableAutomaticIdGeneration != true
            if ((body.id === undefined || body.id === "") && !options.disableAutomaticIdGeneration) {
                body.id = common_1.Helper.generateGuidId();
            }
            const err = {};
            if (!common_1.Helper.isResourceValid(body, err)) {
                throw err;
            }
            const path = common_1.Helper.getPathFromLink(this.container.url, "docs");
            const id = common_1.Helper.getIdFromLink(this.container.url);
            const response = (yield this.clientContext.upsert(body, path, "docs", id, undefined, options));
            const ref = new Item_1.Item(this.container, response.result.id, (options && options.partitionKey), this.clientContext);
            return {
                body: response.result,
                headers: response.headers,
                ref,
                item: ref
            };
        });
    }
}
exports.Items = Items;
//# sourceMappingURL=Items.js.map