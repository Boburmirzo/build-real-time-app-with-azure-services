"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const routing_1 = require("../../routing");
const MockClientContext_1 = require("../common/MockClientContext");
describe("Smart Routing Map Provider OverlappingRanges", function () {
    const containerLink = "dbs/7JZZAA==/colls/7JZZAOS-JQA=/";
    const containerId = "my container";
    const partitionKeyRanges = [
        { id: "0", minInclusive: "", maxExclusive: "05C1C9CD673398" },
        {
            id: "1",
            minInclusive: "05C1C9CD673398",
            maxExclusive: "05C1D9CD673398"
        },
        {
            id: "2",
            minInclusive: "05C1D9CD673398",
            maxExclusive: "05C1E399CD6732"
        },
        {
            id: "3",
            minInclusive: "05C1E399CD6732",
            maxExclusive: "05C1E9CD673398"
        },
        { id: "4", minInclusive: "05C1E9CD673398", maxExclusive: "FF" }
    ];
    const mockedClientContext = new MockClientContext_1.MockedClientContext(partitionKeyRanges, containerId);
    const smartRoutingMapProvider = new routing_1.SmartRoutingMapProvider(mockedClientContext);
    const partitionKeyRangeCache = new routing_1.PartitionKeyRangeCache(mockedClientContext);
    describe("Test Full Range", function () {
        it('query ranges: ["", ""FF)', function () {
            // query range is the whole partition key range
            const pkRange = new routing_1.QueryRange("", "FF", true, false);
            return validateOverlappingRanges([pkRange], partitionKeyRanges);
        });
        it('query ranges: ("", ""FF)', function () {
            // query range is the whole partition key range
            const pkRange = new routing_1.QueryRange("", "FF", false, false);
            return validateOverlappingRanges([pkRange], partitionKeyRanges);
        });
    });
    describe("Test Empty Range", function () {
        it("empty query range list", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                // query range list is empty
                try {
                    yield validateOverlappingRanges([], []);
                }
                catch (err) {
                    throw err;
                }
            });
        });
        it('query ranges: ("", ""]', function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                // validate the overlaping partition key ranges results for empty ranges is empty
                try {
                    yield validateOverlappingRanges([new routing_1.QueryRange("", "", false, true)], []);
                }
                catch (err) {
                    throw err;
                }
            });
        });
        it('query ranges: ("", "")', function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                // validate the overlaping partition key ranges results for empty ranges is empty
                try {
                    yield validateOverlappingRanges([new routing_1.QueryRange("", "", false, false)], []);
                }
                catch (err) {
                    throw err;
                }
            });
        });
        it('query ranges: ["", "")', function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                // validate the overlaping partition key ranges results for empty ranges is empty
                try {
                    yield validateOverlappingRanges([new routing_1.QueryRange("", "", true, false)], []);
                }
                catch (err) {
                    throw err;
                }
            });
        });
    });
    describe("Error Handling: Bad Overlapping Query Range", function () {
        it("overlapping query ranges (in a point)", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const r1 = new routing_1.QueryRange("", "AA", true, true);
                const r2 = new routing_1.QueryRange("AA", "FF", true, false);
                try {
                    yield validateSmartOverlappingRanges([r1, r2], undefined, true);
                }
                catch (err) {
                    throw err;
                }
            });
        });
        it("overlapping query ranges (in a range)", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const r1 = new routing_1.QueryRange("", "AB", true, false);
                const r2 = new routing_1.QueryRange("AA", "FA", true, false);
                try {
                    yield validateSmartOverlappingRanges([r1, r2], undefined, true);
                }
                catch (err) {
                    throw err;
                }
            });
        });
        it("not sorted query ranges", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const r1 = new routing_1.QueryRange("AB", "AC", true, false);
                const r2 = new routing_1.QueryRange("AA", "AB", true, false);
                try {
                    yield validateSmartOverlappingRanges([r1, r2], undefined, true);
                }
                catch (err) {
                    throw err;
                }
            });
        });
    });
    it("Empty Ranges are thrown away", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const e1 = new routing_1.QueryRange("", "", true, false);
            const r1 = new routing_1.QueryRange("", "AB", true, false);
            const e2 = new routing_1.QueryRange("AB", "AB", true, false);
            const r2 = new routing_1.QueryRange("AB", "AC", true, false);
            const e3 = new routing_1.QueryRange("AC", "AC", true, false);
            const e4 = new routing_1.QueryRange("AD", "AD", true, false);
            try {
                yield assertOverlappingRangesAreEqual([e1, r1, e2, r2, e3, e4], [r1, r2]);
            }
            catch (err) {
                throw err;
            }
        });
    });
    it("Single Query Range", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const r = new routing_1.QueryRange("AB", "AC", true, false);
                yield assertBothProvidersResultsEqual([r]);
            }
            catch (err) {
                throw err;
            }
        });
    });
    it("Multiple Query Ranges", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const ranges = [
                    new routing_1.QueryRange("0000000040", "0000000045", true, false),
                    new routing_1.QueryRange("0000000045", "0000000046", true, false),
                    new routing_1.QueryRange("0000000046", "0000000050", true, false)
                ];
                yield assertBothProvidersResultsEqual(ranges);
            }
            catch (err) {
                throw err;
            }
        });
    });
    it("Single Boundary Case Query Range", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const ranges = [new routing_1.QueryRange("05C1C9CD673398", "05C1D9CD673398", true, false)];
            try {
                yield validateOverlappingRanges(ranges, partitionKeyRanges.slice(1, 2));
            }
            catch (err) {
                throw err;
            }
        });
    });
    it("Two Adjacent Boundary Case Query Ranges", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const ranges = [
                // partitionKeyRanges[1]
                new routing_1.QueryRange("05C1C9CD673398", "05C1D9CD673398", true, false),
                // partitionKeyRanges[2]
                new routing_1.QueryRange("05C1D9CD673398", "05C1D9CD673399", true, false)
            ];
            try {
                yield validateOverlappingRanges(ranges, partitionKeyRanges.slice(1, 3));
            }
            catch (err) {
                throw err;
            }
        });
    });
    it("Two Ranges in one partition key range", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const ranges = [
                // two ranges fall in the same partition key range
                new routing_1.QueryRange("05C1C9CD673400", "05C1C9CD673401", true, false),
                new routing_1.QueryRange("05C1C9CD673402", "05C1C9CD673403", true, false)
            ];
            try {
                yield validateOverlappingRanges(ranges, partitionKeyRanges.slice(1, 2));
            }
            catch (err) {
                throw err;
            }
        });
    });
    it("Complex", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const ranges = [
                // all are covered by partitionKeyRanges[1]
                new routing_1.QueryRange("05C1C9CD673398", "05C1D9CD673391", true, false),
                new routing_1.QueryRange("05C1D9CD673391", "05C1D9CD673392", true, false),
                new routing_1.QueryRange("05C1D9CD673393", "05C1D9CD673395", true, false),
                new routing_1.QueryRange("05C1D9CD673395", "05C1D9CD673395", true, false),
                // all are covered by partitionKeyRanges[4]]
                new routing_1.QueryRange("05C1E9CD673398", "05C1E9CD673401", true, false),
                new routing_1.QueryRange("05C1E9CD673402", "05C1E9CD673403", true, false),
                // empty range
                new routing_1.QueryRange("FF", "FF", true, false)
            ];
            try {
                yield validateOverlappingRanges(ranges, [partitionKeyRanges[1], partitionKeyRanges[4]]);
            }
            catch (err) {
                throw err;
            }
        });
    });
    // Validates the results
    // smartRoutingMapProvider.getOverlappingRanges()
    // partitionKeyRangeCache.getOverlappingRanges() is equal
    const assertBothProvidersResultsEqual = (queryRanges) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        let results1;
        let results2;
        let err1;
        let err2;
        results1 = results2 = null;
        err1 = err2 = null;
        try {
            results1 = yield smartRoutingMapProvider.getOverlappingRanges(containerLink, queryRanges);
        }
        catch (err) {
            err1 = err;
        }
        try {
            results2 = yield partitionKeyRangeCache.getOverlappingRanges(containerLink, queryRanges);
        }
        catch (err) {
            err2 = err;
        }
        assert_1.default.equal(err1, err2);
        assert_1.default.deepEqual(results1, results2);
    });
    // Validates the results
    // smartRoutingMapProvider.getOverlappingRanges()
    // partitionKeyRangeCache.getOverlappingRanges() is as expected
    const validateOverlappingRanges = function (queryRanges, expectedResults, errorExpected) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                errorExpected = errorExpected || false;
                yield validateSmartOverlappingRanges(queryRanges, expectedResults, errorExpected);
                yield validatePartitionKeyRangeCacheOverlappingRanges(queryRanges, expectedResults, errorExpected);
            }
            catch (err) {
                throw err;
            }
        });
    };
    // Validates the results of both
    // smartRoutingMapProvider.getOverlappingRanges()
    // partitionKeyRangeCache.getOverlappingRanges() is the same for both queryRanges1, queryRanges2
    const assertOverlappingRangesAreEqual = function (queryRanges1, queryRanges2) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                yield assertProviderOverlappingRangesAreEqual(smartRoutingMapProvider, queryRanges1, queryRanges2);
                yield assertProviderOverlappingRangesAreEqual(partitionKeyRangeCache, queryRanges1, queryRanges2);
                yield assertBothProvidersResultsEqual(queryRanges1);
            }
            catch (err) {
                throw err;
            }
        });
    };
    // Validates the results
    // provider.getOverlappingRanges() is the same on both queryRanges1, queryRanges2
    const assertProviderOverlappingRangesAreEqual = function (provider, queryRanges1, queryRanges2) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let results1;
            let results2;
            let err1;
            let err2;
            try {
                results1 = yield provider.getOverlappingRanges(containerLink, queryRanges1);
            }
            catch (err) {
                err1 = err;
            }
            try {
                results2 = yield provider.getOverlappingRanges(containerLink, queryRanges2);
            }
            catch (err) {
                err2 = err;
            }
            assert_1.default.equal(err1, err2);
            assert_1.default.deepEqual(results1, results2);
        });
    };
    // Validates the results
    // provider.getOverlappingRanges() is as expected
    const validateProviderOverlappingRanges = function (provider, queryRanges, expectedResults, errorExpected) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            errorExpected = errorExpected || false;
            try {
                const results = yield provider.getOverlappingRanges(containerLink, queryRanges);
                assert_1.default.deepEqual(results, expectedResults);
            }
            catch (err) {
                if (errorExpected) {
                    assert_1.default.notEqual(err, undefined);
                    return;
                }
                else {
                    throw err;
                }
            }
        });
    };
    // validates that the results of
    // smartRoutingMapProvider.getOverlappingRanges() is as expected
    const validateSmartOverlappingRanges = function (queryRanges, expectedResults, errorExpected) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                yield validateProviderOverlappingRanges(smartRoutingMapProvider, queryRanges, expectedResults, errorExpected);
            }
            catch (err) {
                throw err;
            }
        });
    };
    // validates that the results of
    // partitionKeyRangeCache.getOverlappingRanges() is as expected
    const validatePartitionKeyRangeCacheOverlappingRanges = function (queryRanges, expectedResults, errorExpected) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                yield validateProviderOverlappingRanges(partitionKeyRangeCache, queryRanges, expectedResults, errorExpected);
            }
            catch (err) {
                throw err;
            }
        });
    };
});
//# sourceMappingURL=smartRoutingMapProvider.spec.js.map