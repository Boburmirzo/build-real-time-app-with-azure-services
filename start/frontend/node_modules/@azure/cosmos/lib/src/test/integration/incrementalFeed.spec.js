"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const common_1 = require("../../common");
const TestHelpers_1 = require("../common/TestHelpers");
describe("Change Feed Iterator", function () {
    this.timeout(process.env.MOCHA_TIMEOUT || 20000);
    describe("Non-partitioned", function () {
        // delete all databases and create sample database
        before(function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield TestHelpers_1.removeAllDatabases();
            });
        });
        (process.env.TESTS_MULTIREGION ? describe.skip : describe)("Should only find items after start time", function () {
            let container;
            // create container and two items
            before(function () {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    container = yield TestHelpers_1.getTestContainer("Newly updated items should be fetched incrementally");
                });
            });
            after(function () {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    yield container.delete();
                });
            });
            it("should fetch updated items only with start time", function () {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    yield container.items.create({ id: "item1" });
                    const date = new Date();
                    yield common_1.Helper.sleep(3000);
                    yield container.items.create({ id: "item2" });
                    const iterator = container.items.readChangeFeed({ startTime: date });
                    const { result: itemsShouldBeEmpty, etag: initialEtag } = yield iterator.executeNext();
                    assert_1.default(initialEtag, "change feed response should have etag header");
                    const etag = initialEtag;
                    assert_1.default.equal(itemsShouldBeEmpty.length, 0, "Initial request should have empty results");
                    const { result: items } = yield iterator.executeNext();
                    assert_1.default.equal(items.length, 1, "initial number of items should be equal 1");
                    assert_1.default.equal(items[0].id, "item2", "should find the newest item, but not the old");
                    const item = { id: "item2", name: "xyz" };
                    const { body: replaced } = yield container.item(item.id).replace(item);
                    assert_1.default.deepEqual(replaced.name, "xyz", "replaced item should be valid");
                    // Should continue from last etag
                    const { result: itemsAfterUpdate } = yield iterator.executeNext();
                    assert_1.default.equal(itemsAfterUpdate.length, 1, "initial number of items should be equal 1");
                    assert_1.default.equal(itemsAfterUpdate[0].name, "xyz", "fetched item should have 'name: xyz'");
                    assert_1.default.equal(itemsAfterUpdate[0].id, item.id, "fetched item should be valid");
                    // Equivalent to execute next on other iterator from the previous etag
                    const iteratorWithContinuation = container.items.readChangeFeed({ continuation: etag });
                    const { result: itemsWithContinuation } = yield iteratorWithContinuation.executeNext();
                    assert_1.default.equal(itemsWithContinuation.length, 1, "initial number of items should be equal 1");
                    assert_1.default.equal(itemsWithContinuation[0].name, "xyz", "fetched item should have 'name: xyz'");
                    assert_1.default.equal(itemsWithContinuation[0].id, item.id, "fetched item should be valid");
                    const { result: shouldHaveNoItems } = yield iterator.executeNext();
                    assert_1.default.equal(shouldHaveNoItems.length, 0, "there should be 0 results");
                    const hasMoreResults = iterator.hasMoreResults;
                    assert_1.default.equal(hasMoreResults, false, "hasMoreResults should be false when we read the whole page");
                });
            });
        });
        describe("Newly updated items should be fetched incrementally", function () {
            let container;
            // create container and two items
            before(function () {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    container = yield TestHelpers_1.getTestContainer("Newly updated items should be fetched incrementally");
                    yield container.items.create({ id: "item1" });
                    yield container.items.create({ id: "item2" });
                });
            });
            after(function () {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    yield container.delete();
                });
            });
            it("should fetch updated items only", function () {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const iterator = container.items.readChangeFeed({ startFromBeginning: true });
                    const { result: items, headers } = yield iterator.executeNext();
                    assert_1.default(headers.etag, "change feed response should have etag header");
                    const etag = headers.etag;
                    assert_1.default.equal(items.length, 2, "initial number of items should be equal 2");
                    const item = items[1];
                    item.name = "xyz";
                    const { body: replaced } = yield container.item(item.id).replace(item);
                    assert_1.default.deepEqual(replaced.name, "xyz", "replaced item should be valid");
                    // Should continue from last etag
                    const { result: itemsAfterUpdate } = yield iterator.executeNext();
                    assert_1.default.equal(itemsAfterUpdate.length, 1, "initial number of items should be equal 1");
                    assert_1.default.equal(itemsAfterUpdate[0].name, "xyz", "fetched item should have 'name: xyz'");
                    assert_1.default.equal(itemsAfterUpdate[0].id, item.id, "fetched item should be valid");
                    // Equivalent to execute next on other iterator from the previous etag
                    const iteratorWithContinuation = container.items.readChangeFeed({ continuation: etag });
                    const { result: itemsWithContinuation } = yield iteratorWithContinuation.executeNext();
                    assert_1.default.equal(itemsWithContinuation.length, 1, "initial number of items should be equal 1");
                    assert_1.default.equal(itemsWithContinuation[0].name, "xyz", "fetched item should have 'name: xyz'");
                    assert_1.default.equal(itemsWithContinuation[0].id, item.id, "fetched item should be valid");
                    const { result: shouldHaveNoItems } = yield iterator.executeNext();
                    assert_1.default.equal(shouldHaveNoItems.length, 0, "there should be 0 results");
                    const hasMoreResults = iterator.hasMoreResults;
                    assert_1.default.equal(hasMoreResults, false, "hasMoreResults should be false when we read the whole page");
                });
            });
        });
        describe("Async iterator should find items", function () {
            let container;
            // create container and two items
            before(function () {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    container = yield TestHelpers_1.getTestContainer("Newly updated items should be fetched incrementally");
                    yield container.items.create({ id: "item1" });
                    yield container.items.create({ id: "item2" });
                });
            });
            after(function () {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    yield container.delete();
                });
            });
            it("should fetch updated items only", function () {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    var e_1, _a, e_2, _b, e_3, _c;
                    const iterator = container.items.readChangeFeed({ startFromBeginning: true });
                    const items = [];
                    try {
                        for (var _d = tslib_1.__asyncValues(iterator.getAsyncIterator()), _e; _e = yield _d.next(), !_e.done;) {
                            const page = _e.value;
                            if (page.result.length === 0) {
                                break;
                            }
                            items.push(...page.result);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_e && !_e.done && (_a = _d.return)) yield _a.call(_d);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    assert_1.default.equal(items.length, 2, "initial number of items should be equal 2");
                    const item = items[1];
                    item.name = "xyz";
                    const { body: replaced } = yield container.item(item.id).replace(item);
                    assert_1.default.deepEqual(replaced.name, "xyz", "replaced item should be valid");
                    // Should continue from last etag
                    const itemsAfterUpdate = [];
                    try {
                        for (var _f = tslib_1.__asyncValues(iterator.getAsyncIterator()), _g; _g = yield _f.next(), !_g.done;) {
                            const page = _g.value;
                            if (page.result.length === 0) {
                                break;
                            }
                            itemsAfterUpdate.push(...page.result);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_g && !_g.done && (_b = _f.return)) yield _b.call(_f);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    assert_1.default.equal(itemsAfterUpdate.length, 1, "initial number of items should be equal 1");
                    assert_1.default.equal(itemsAfterUpdate[0].name, "xyz", "fetched item should have 'name: xyz'");
                    assert_1.default.equal(itemsAfterUpdate[0].id, item.id, "fetched item should be valid");
                    const { result: shouldHaveNoItems } = yield iterator.executeNext();
                    assert_1.default.equal(shouldHaveNoItems.length, 0, "there should be 0 results");
                    const hasMoreResults = iterator.hasMoreResults;
                    assert_1.default.equal(hasMoreResults, false, "hasMoreResults should be false when we read the whole page");
                    let count = 0;
                    try {
                        for (var _h = tslib_1.__asyncValues(iterator.getAsyncIterator()), _j; _j = yield _h.next(), !_j.done;) {
                            const page = _j.value;
                            ++count;
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_j && !_j.done && (_c = _h.return)) yield _c.call(_h);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                    assert_1.default.equal(count, 0, "async iterator should return any results if there are none left to serve");
                });
            });
        });
        describe("Newly created items should be fetched incrementally", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                let container;
                // create container and one item
                before(function () {
                    return tslib_1.__awaiter(this, void 0, void 0, function* () {
                        container = yield TestHelpers_1.getTestContainer("Newly updated items should be fetched incrementally");
                        yield container.items.create({ id: "item1" });
                    });
                });
                after(function () {
                    return tslib_1.__awaiter(this, void 0, void 0, function* () {
                        yield container.delete();
                    });
                });
                it("should fetch new items only", function () {
                    return tslib_1.__awaiter(this, void 0, void 0, function* () {
                        const iterator = container.items.readChangeFeed({});
                        const { result: items, headers } = yield iterator.executeNext();
                        assert_1.default(headers.etag, "change feed response should have etag header");
                        assert_1.default.equal(items.length, 0, "change feed response should have no items on it initially");
                        const { body: itemThatWasCreated } = yield container.items.create({
                            id: "item2",
                            prop: 1
                        });
                        const { result: itemsAfterCreate } = yield iterator.executeNext();
                        assert_1.default.equal(itemsAfterCreate.length, 1, "should have 1 item from create");
                        const itemThatWasFound = itemsAfterCreate[0];
                        assert_1.default.notDeepEqual(itemThatWasFound, itemThatWasCreated, "actual should not match with expected value.");
                        delete itemThatWasFound._lsn;
                        delete itemThatWasFound._metadata;
                        assert_1.default.deepEqual(itemThatWasFound, itemThatWasCreated, "actual value doesn't match with expected value.");
                        const { result: itemsShouldBeEmptyWithNoNewCreates } = yield iterator.executeNext();
                        assert_1.default.equal(itemsShouldBeEmptyWithNoNewCreates.length, 0, "should be nothing new");
                        yield container.items.create({ id: "item3" });
                        yield container.items.create({ id: "item4" });
                        const { result: itemsShouldHave2NewItems } = yield iterator.executeNext();
                        assert_1.default.equal(itemsShouldHave2NewItems.length, 2, "there should be 2 results");
                        const { result: shouldHaveNoItems } = yield iterator.executeNext();
                        assert_1.default.equal(shouldHaveNoItems.length, 0, "there should be 0 results");
                        const hasMoreResults = iterator.hasMoreResults;
                        assert_1.default.equal(hasMoreResults, false, "hasMoreResults should be false when we read the whole page");
                    });
                });
            });
        });
    });
    describe("Partition Key", function () {
        // delete all databases and create sample database
        before(function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield TestHelpers_1.removeAllDatabases();
            });
        });
        describe("Newly updated items should be fetched incrementally", function () {
            let container;
            // create container and two items
            before(function () {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const containerDef = {
                        partitionKey: {
                            kind: "Hash",
                            paths: ["/key"]
                        }
                    };
                    const throughput = { offerThroughput: 25100 };
                    container = yield TestHelpers_1.getTestContainer("Newly updated items should be fetched incrementally", undefined, containerDef, throughput);
                    yield container.items.create({ id: "item1", key: "0" });
                    yield container.items.create({ id: "item2", key: "0" });
                    yield container.items.create({ id: "item1", key: "1" });
                    yield container.items.create({ id: "item2", key: "1" });
                });
            });
            after(function () {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    yield container.delete();
                });
            });
            it("should throw if used with no partition key or partition key range id", function () {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const iterator = container.items.readChangeFeed({ startFromBeginning: true });
                    try {
                        yield iterator.executeNext();
                    }
                    catch (err) {
                        assert_1.default.equal(err.message, "Container is partitioned, but no partition key or partition key range id was specified.");
                        return;
                    }
                    assert_1.default.fail("Should have failed");
                });
            });
            it("should fetch updated items only", function () {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const iterator = container.items.readChangeFeed("0", { startFromBeginning: true });
                    const { result: items, headers } = yield iterator.executeNext();
                    assert_1.default(headers.etag, "change feed response should have etag header");
                    assert_1.default.equal(items.length, 2, "initial number of items should be equal 2");
                    const item = items[1];
                    item.name = "xyz";
                    const { body: replaced } = yield container.item(item.id).replace(item);
                    assert_1.default.deepEqual(replaced.name, "xyz", "replaced item should be valid");
                    const { result: itemsAfterUpdate } = yield iterator.executeNext();
                    assert_1.default.equal(itemsAfterUpdate.length, 1, "initial number of items should be equal 1");
                    assert_1.default.equal(itemsAfterUpdate[0].name, "xyz", "fetched item should have 'name: xyz'");
                    assert_1.default.equal(itemsAfterUpdate[0].id, item.id, "fetched item should be valid");
                    const { result: shouldHaveNoItems } = yield iterator.executeNext();
                    assert_1.default.equal(shouldHaveNoItems.length, 0, "there should be 0 results");
                    const hasMoreResults = iterator.hasMoreResults;
                    assert_1.default.equal(hasMoreResults, false, "hasMoreResults should be false when we read the whole page");
                });
            });
        });
        describe("Newly created items should be fetched incrementally", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                let container;
                // create container and one item
                before(function () {
                    return tslib_1.__awaiter(this, void 0, void 0, function* () {
                        const containerDef = {
                            partitionKey: {
                                kind: "Hash",
                                paths: ["/key"]
                            }
                        };
                        const throughput = { offerThroughput: 25100 };
                        container = yield TestHelpers_1.getTestContainer("Newly updated items should be fetched incrementally", undefined, containerDef, throughput);
                        yield container.items.create({ id: "item1", key: "0" });
                        yield container.items.create({ id: "item1", key: "1" });
                    });
                });
                after(function () {
                    return tslib_1.__awaiter(this, void 0, void 0, function* () {
                        yield container.delete();
                    });
                });
                it("should fetch new items only", function () {
                    return tslib_1.__awaiter(this, void 0, void 0, function* () {
                        const iterator = container.items.readChangeFeed("0", {});
                        const { result: items, headers } = yield iterator.executeNext();
                        assert_1.default(headers.etag, "change feed response should have etag header");
                        assert_1.default.equal(items.length, 0, "change feed response should have no items on it initially");
                        const { body: itemThatWasCreated, headers: createHeaders } = yield container.items.create({
                            id: "item2",
                            prop: 1,
                            key: "0"
                        });
                        const { result: itemsAfterCreate } = yield iterator.executeNext();
                        assert_1.default.equal(itemsAfterCreate.length, 1, "should have 1 item from create");
                        const itemThatWasFound = itemsAfterCreate[0];
                        assert_1.default.notDeepEqual(itemThatWasFound, itemThatWasCreated, "actual should not match with expected value.");
                        delete itemThatWasFound._lsn;
                        delete itemThatWasFound._metadata;
                        assert_1.default.deepEqual(itemThatWasFound, itemThatWasCreated, "actual value doesn't match with expected value.");
                        const { result: itemsShouldBeEmptyWithNoNewCreates } = yield iterator.executeNext();
                        assert_1.default.equal(itemsShouldBeEmptyWithNoNewCreates.length, 0, "should be nothing new");
                        yield container.items.create({ id: "item3", key: "0" });
                        yield container.items.create({ id: "item4", key: "0" });
                        yield container.items.create({ id: "item3", key: "1" });
                        yield container.items.create({ id: "item4", key: "1" });
                        const { result: itemsShouldHave2NewItems } = yield iterator.executeNext();
                        assert_1.default.equal(itemsShouldHave2NewItems.length, 2, "there should be 2 results");
                        const { result: shouldHaveNoItems } = yield iterator.executeNext();
                        assert_1.default.equal(shouldHaveNoItems.length, 0, "there should be 0 results");
                        const hasMoreResults = iterator.hasMoreResults;
                        assert_1.default.equal(hasMoreResults, false, "hasMoreResults should be false when we read the whole page");
                    });
                });
            });
        });
    });
});
//# sourceMappingURL=incrementalFeed.spec.js.map