"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const common_1 = require("../../common");
const sessionContainer_1 = require("../../session/sessionContainer");
describe("SessionContainer", function () {
    const collectionLink = "dbs/testDatabase/colls/testCollection";
    const collectionId = "oWxIAN48yN0=";
    it("set/get/delete", function () {
        const sc = new sessionContainer_1.SessionContainer();
        const tokenString = "1:1#100#1=20#2=5#3=30";
        const nameBasedRequest = {
            isNameBased: true,
            resourceId: null,
            resourceAddress: "/" + collectionLink + "/",
            resourceType: "docs",
            operationType: "create"
        };
        const resHeadersNameBased = {};
        resHeadersNameBased[common_1.Constants.HttpHeaders.OwnerFullName] = collectionLink;
        resHeadersNameBased[common_1.Constants.HttpHeaders.OwnerId] = collectionId;
        resHeadersNameBased[common_1.Constants.HttpHeaders.SessionToken] = tokenString;
        // Add a token and get new token, should be equal
        sc.set(nameBasedRequest, resHeadersNameBased);
        const originalTokenString = sc.get(nameBasedRequest);
        assert_1.default.equal(tokenString, originalTokenString, "Session token string must be equal to original header on initial set");
        // Add an older token, should still equal original token
        const tokenStringWithOlderVersion = "1:1#99#1=19#2=4#3=29";
        resHeadersNameBased[common_1.Constants.HttpHeaders.SessionToken] = tokenStringWithOlderVersion;
        sc.set(nameBasedRequest, resHeadersNameBased);
        const sameTokenString = sc.get(nameBasedRequest);
        assert_1.default.equal(tokenString, sameTokenString, "Session token string must be equal to the original higher version header");
        // Add a newer version token, should equal new token
        const tokenStringWithNewerVersion = "1:1#100#1=30#2=10#3=40";
        resHeadersNameBased[common_1.Constants.HttpHeaders.SessionToken] = tokenStringWithNewerVersion;
        sc.set(nameBasedRequest, resHeadersNameBased);
        const updatedTokenString = sc.get(nameBasedRequest);
        assert_1.default.equal(tokenStringWithNewerVersion, updatedTokenString, "Session token string must be equal to the new higher version header");
        // Add a new partition's token, should container new and old token
        const tokenFromAnotherPartition = "2:1#100#1=10";
        resHeadersNameBased[common_1.Constants.HttpHeaders.SessionToken] = tokenFromAnotherPartition;
        sc.set(nameBasedRequest, resHeadersNameBased);
        const multiplePartitions = sc.get(nameBasedRequest);
        assert_1.default(multiplePartitions.includes(tokenStringWithNewerVersion), "Token string must contain token from updated request");
        assert_1.default(multiplePartitions.includes(tokenFromAnotherPartition), "Token string must contain from new partition");
        // Add a token with has multiple partitions in it, 1 old, and 1 new. Should only keep the new one, but still contain tokens for both
        const p2TokenWithNewerVersion = "2:2#100#1=10#2=50";
        const tokenWithMultiplePartitions = `${tokenStringWithOlderVersion},${p2TokenWithNewerVersion}`;
        resHeadersNameBased[common_1.Constants.HttpHeaders.SessionToken] = tokenWithMultiplePartitions;
        sc.set(nameBasedRequest, resHeadersNameBased);
        const multiplePartitions2 = sc.get(nameBasedRequest);
        assert_1.default(multiplePartitions2.includes(tokenStringWithNewerVersion), "Token string must contain token from previous request for first partition");
        assert_1.default(multiplePartitions2.includes(p2TokenWithNewerVersion), "Token string must contain from updated token for second partition");
        // Remove tokens and get new token, should be empty
        sc.remove(nameBasedRequest);
        const emptyTokenString = sc.get(nameBasedRequest);
        assert_1.default.equal("", emptyTokenString, "Session token string must be empty after removal");
    });
});
//# sourceMappingURL=sessionContainer.spec.js.map