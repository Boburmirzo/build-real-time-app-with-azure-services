"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const __1 = require("../..");
const TestHelpers_1 = require("../common/TestHelpers");
describe("NodeJS CRUD Tests", function () {
    this.timeout(process.env.MOCHA_TIMEOUT || 10000);
    beforeEach(function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield TestHelpers_1.removeAllDatabases();
        });
    });
    describe("Validate spatial index", function () {
        const spatialIndexTest = function (isUpsertTest) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    // create database
                    const database = yield TestHelpers_1.getTestDatabase("validate spatial index");
                    // create container using an indexing policy with spatial index.
                    const indexingPolicy = {
                        includedPaths: [
                            {
                                path: '/"Location"/?',
                                indexes: [
                                    {
                                        kind: __1.DocumentBase.IndexKind.Spatial,
                                        dataType: __1.DocumentBase.DataType.Point
                                    }
                                ]
                            },
                            {
                                path: "/"
                            }
                        ]
                    };
                    const entropy = Math.floor(Math.random() * 10000);
                    const { body: containerDef } = yield database.containers.create({
                        id: `sample container${entropy}`,
                        indexingPolicy
                    });
                    const container = database.container(containerDef.id);
                    const location1 = {
                        id: "location1",
                        Location: {
                            type: "Point",
                            coordinates: [20.0, 20.0]
                        }
                    };
                    yield TestHelpers_1.createOrUpsertItem(container, location1, undefined, isUpsertTest);
                    const location2 = {
                        id: "location2",
                        Location: {
                            type: "Point",
                            coordinates: [100.0, 100.0]
                        }
                    };
                    yield TestHelpers_1.createOrUpsertItem(container, location2, undefined, isUpsertTest);
                    const query = "SELECT * FROM root WHERE (ST_DISTANCE(root.Location, {type: 'Point', coordinates: [20.1, 20]}) < 20000) ";
                    const { result: results } = yield container.items.query(query).toArray();
                    assert_1.default.equal(1, results.length);
                    assert_1.default.equal("location1", results[0].id);
                }
                catch (err) {
                    throw err;
                }
            });
        };
        it("nativeApi Should support spatial index name based", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    yield spatialIndexTest(false);
                }
                catch (err) {
                    throw err;
                }
            });
        });
        it("nativeApi Should support spatial index name based with upsert", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    yield spatialIndexTest(true);
                }
                catch (err) {
                    throw err;
                }
            });
        });
    });
});
//# sourceMappingURL=spatial.spec.js.map