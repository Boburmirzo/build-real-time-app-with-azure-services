"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const __1 = require("../..");
const _testConfig_1 = require("./_testConfig");
const defaultClient = new __1.CosmosClient({ endpoint: _testConfig_1.endpoint, auth: { masterKey: _testConfig_1.masterKey } });
function addEntropy(name) {
    return name + getEntropy();
}
exports.addEntropy = addEntropy;
function getEntropy() {
    return `${Math.floor(Math.random() * 10000)}`;
}
exports.getEntropy = getEntropy;
function removeAllDatabases(client = defaultClient) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const { result: databases } = yield client.databases.readAll().toArray();
            const length = databases.length;
            if (length === 0) {
                return;
            }
            const count = 0;
            yield Promise.all(databases.map((database) => tslib_1.__awaiter(this, void 0, void 0, function* () { return client.database(database.id).delete(); })));
        }
        catch (err) {
            // TODO: remove console logging for errors and add ts-lint flag back
            console.log("An error occured", err);
            assert_1.default.fail(err);
            throw err;
        }
    });
}
exports.removeAllDatabases = removeAllDatabases;
function getTestDatabase(testName, client = defaultClient) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const entropy = Math.floor(Math.random() * 10000);
        const id = `${testName.replace(" ", "").substring(0, 30)}${entropy}`;
        yield client.databases.create({ id });
        return client.database(id);
    });
}
exports.getTestDatabase = getTestDatabase;
function getTestContainer(testName, client = defaultClient, containerDef, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const db = yield getTestDatabase(testName, client);
        const entropy = Math.floor(Math.random() * 10000);
        const id = `${testName.replace(" ", "").substring(0, 30)}${entropy}`;
        yield db.containers.create(Object.assign({}, containerDef, { id }), options);
        return db.container(id);
    });
}
exports.getTestContainer = getTestContainer;
function bulkInsertItems(container, documents) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const returnedDocuments = [];
        for (const doc of documents) {
            try {
                const { body: document } = yield container.items.create(doc);
                returnedDocuments.push(document);
            }
            catch (err) {
                throw err;
            }
        }
        return returnedDocuments;
    });
}
exports.bulkInsertItems = bulkInsertItems;
function bulkReadItems(container, documents, partitionKey) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        for (const document of documents) {
            try {
                const options = partitionKey && document.hasOwnProperty(partitionKey)
                    ? { partitionKey: document[partitionKey] }
                    : { partitionKey: {} };
                // TODO: should we block or do all requests in parallel?
                const { body: doc } = yield container.item(document.id).read(options);
                assert_1.default.equal(JSON.stringify(doc), JSON.stringify(document));
            }
            catch (err) {
                throw err;
            }
        }
    });
}
exports.bulkReadItems = bulkReadItems;
function bulkReplaceItems(container, documents) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const returnedDocuments = [];
        for (const document of documents) {
            try {
                const { body: doc } = yield container.item(document.id).replace(document);
                const expectedModifiedDocument = JSON.parse(JSON.stringify(document));
                delete expectedModifiedDocument._etag;
                delete expectedModifiedDocument._ts;
                const actualModifiedDocument = JSON.parse(JSON.stringify(doc));
                delete actualModifiedDocument._etag;
                delete actualModifiedDocument._ts;
                assert_1.default.equal(JSON.stringify(actualModifiedDocument), JSON.stringify(expectedModifiedDocument));
                returnedDocuments.push(doc);
            }
            catch (err) {
                throw err;
            }
        }
        return returnedDocuments;
    });
}
exports.bulkReplaceItems = bulkReplaceItems;
function bulkDeleteItems(container, documents, partitionKeyPropertyName) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        for (const document of documents) {
            try {
                const options = partitionKeyPropertyName && document.hasOwnProperty(partitionKeyPropertyName)
                    ? { partitionKey: document[partitionKeyPropertyName] }
                    : { partitionKey: {} };
                yield container.item(document.id).delete(options);
            }
            catch (err) {
                throw err;
            }
        }
    });
}
exports.bulkDeleteItems = bulkDeleteItems;
function bulkQueryItemsWithPartitionKey(container, documents, partitionKeyPropertyName) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        for (const document of documents) {
            try {
                if (!document.hasOwnProperty(partitionKeyPropertyName)) {
                    continue;
                }
                const querySpec = {
                    query: "SELECT * FROM root r WHERE r." + partitionKeyPropertyName + "=@key",
                    parameters: [
                        {
                            name: "@key",
                            value: document[partitionKeyPropertyName]
                        }
                    ]
                };
                const { result: results } = yield container.items.query(querySpec).toArray();
                assert_1.default.equal(results.length, 1, "Expected exactly 1 document");
                assert_1.default.equal(JSON.stringify(results[0]), JSON.stringify(document));
            }
            catch (err) {
                throw err;
            }
        }
    });
}
exports.bulkQueryItemsWithPartitionKey = bulkQueryItemsWithPartitionKey;
// Item
function createOrUpsertItem(container, body, options, isUpsertTest) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (isUpsertTest) {
            return container.items.upsert(body, options);
        }
        else {
            return container.items.create(body, options);
        }
    });
}
exports.createOrUpsertItem = createOrUpsertItem;
function replaceOrUpsertItem(container, body, options, isUpsertTest) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (isUpsertTest) {
            return container.items.upsert(body, options);
        }
        else {
            return container.item(body.id).replace(body, options);
        }
    });
}
exports.replaceOrUpsertItem = replaceOrUpsertItem;
// User
function createOrUpsertUser(database, body, options, isUpsertTest) {
    if (isUpsertTest) {
        return database.users.upsert(body, options);
    }
    else {
        return database.users.create(body, options);
    }
}
exports.createOrUpsertUser = createOrUpsertUser;
function replaceOrUpsertUser(database, body, options, isUpsertTest) {
    if (isUpsertTest) {
        return database.users.upsert(body, options);
    }
    else {
        return database.user(body.id).replace(body, options);
    }
}
exports.replaceOrUpsertUser = replaceOrUpsertUser;
function createOrUpsertPermission(user, body, options, isUpsertTest) {
    if (isUpsertTest) {
        return user.permissions.upsert(body, options);
    }
    else {
        return user.permissions.create(body, options);
    }
}
exports.createOrUpsertPermission = createOrUpsertPermission;
function replaceOrUpsertPermission(user, body, options, isUpsertTest) {
    if (isUpsertTest) {
        return user.permissions.upsert(body, options);
    }
    else {
        return user.permission(body.id).replace(body, options);
    }
}
exports.replaceOrUpsertPermission = replaceOrUpsertPermission;
// Trigger
function createOrUpsertTrigger(container, body, options, isUpsertTest) {
    if (isUpsertTest) {
        return container.triggers.upsert(body, options);
    }
    else {
        return container.triggers.create(body, options);
    }
}
exports.createOrUpsertTrigger = createOrUpsertTrigger;
function replaceOrUpsertTrigger(container, body, options, isUpsertTest) {
    if (isUpsertTest) {
        return container.triggers.upsert(body, options);
    }
    else {
        return container.trigger(body.id).replace(body, options);
    }
}
exports.replaceOrUpsertTrigger = replaceOrUpsertTrigger;
// User Defined Function
function createOrUpsertUserDefinedFunction(container, body, options, isUpsertTest) {
    if (isUpsertTest) {
        return container.userDefinedFunctions.upsert(body, options);
    }
    else {
        return container.userDefinedFunctions.create(body, options);
    }
}
exports.createOrUpsertUserDefinedFunction = createOrUpsertUserDefinedFunction;
function replaceOrUpsertUserDefinedFunction(container, body, options, isUpsertTest) {
    if (isUpsertTest) {
        return container.userDefinedFunctions.upsert(body, options);
    }
    else {
        return container.userDefinedFunction(body.id).replace(body, options);
    }
}
exports.replaceOrUpsertUserDefinedFunction = replaceOrUpsertUserDefinedFunction;
// Stored Procedure
function createOrUpsertStoredProcedure(container, body, options, isUpsertTest) {
    if (isUpsertTest) {
        return container.storedProcedures.upsert(body, options);
    }
    else {
        return container.storedProcedures.create(body, options);
    }
}
exports.createOrUpsertStoredProcedure = createOrUpsertStoredProcedure;
function replaceOrUpsertStoredProcedure(container, body, options, isUpsertTest) {
    if (isUpsertTest) {
        return container.storedProcedures.upsert(body, options);
    }
    else {
        return container.storedProcedure(body.id).replace(body, options);
    }
}
exports.replaceOrUpsertStoredProcedure = replaceOrUpsertStoredProcedure;
//# sourceMappingURL=TestHelpers.js.map