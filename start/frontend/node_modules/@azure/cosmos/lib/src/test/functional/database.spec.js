"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const __1 = require("../..");
const _testConfig_1 = require("../common/_testConfig");
const TestHelpers_1 = require("../common/TestHelpers");
const client = new __1.CosmosClient({ endpoint: _testConfig_1.endpoint, auth: { masterKey: _testConfig_1.masterKey } });
describe("NodeJS CRUD Tests", function () {
    this.timeout(process.env.MOCHA_TIMEOUT || 10000);
    beforeEach(function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield TestHelpers_1.removeAllDatabases();
        });
    });
    describe("Validate Database CRUD", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const databaseCRUDTest = function () {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    // read databases
                    const { result: databases } = yield client.databases.readAll().toArray();
                    assert_1.default.equal(databases.constructor, Array, "Value should be an array");
                    // create a database
                    const beforeCreateDatabasesCount = databases.length;
                    const databaseDefinition = { id: "database test database" };
                    const { body: db } = yield client.databases.create(databaseDefinition);
                    assert_1.default.equal(db.id, databaseDefinition.id);
                    // read databases after creation
                    const { result: databases2 } = yield client.databases.readAll().toArray();
                    assert_1.default.equal(databases2.length, beforeCreateDatabasesCount + 1, "create should increase the number of databases");
                    // query databases
                    const querySpec = {
                        query: "SELECT * FROM root r WHERE r.id=@id",
                        parameters: [
                            {
                                name: "@id",
                                value: databaseDefinition.id
                            }
                        ]
                    };
                    const { result: results } = yield client.databases.query(querySpec).toArray();
                    assert_1.default(results.length > 0, "number of results for the query should be > 0");
                    // delete database
                    yield client.database(db.id).delete();
                    try {
                        // read database after deletion
                        yield client.database(db.id).read();
                        assert_1.default.fail("Read database on non-existent database should fail");
                    }
                    catch (err) {
                        const notFoundErrorCode = 404;
                        assert_1.default.equal(err.code, notFoundErrorCode, "response should return error code 404");
                    }
                });
            };
            it("nativeApi Should do database CRUD operations successfully name based", function () {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    yield databaseCRUDTest();
                });
            });
            describe("databases.createIfNotExists", function () {
                it("should handle does not exist", function () {
                    return tslib_1.__awaiter(this, void 0, void 0, function* () {
                        const def = { id: TestHelpers_1.addEntropy("does not exist") };
                        const { database } = yield client.databases.createIfNotExists(def);
                        const { body: readDef } = yield database.read();
                        assert_1.default.equal(def.id, readDef.id);
                    });
                });
                it("should handle does exist", function () {
                    return tslib_1.__awaiter(this, void 0, void 0, function* () {
                        const def = { id: TestHelpers_1.addEntropy("does  exist") };
                        // Set up
                        yield client.databases.create(def);
                        // Now call createIfNotExists on existing db
                        const { database } = yield client.databases.createIfNotExists(def);
                        const { body: readDef } = yield database.read();
                        assert_1.default.equal(def.id, readDef.id);
                    });
                });
            });
        });
    });
    // TODO: These are unit tests, not e2e tests like above, so maybe should seperate these.
    describe("Validate Id validation", function () {
        it("nativeApi Should fail on ends with a space", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                // Id shoudn't end with a space.
                try {
                    yield client.databases.create({ id: "id_ends_with_space " });
                    assert_1.default.fail("Must throw if id ends with a space");
                }
                catch (err) {
                    assert_1.default.equal("Id ends with a space.", err.message);
                }
            });
        });
        it("nativeAPI Should fail on contains '/'", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                // Id shoudn't contain "/".
                try {
                    yield client.databases.create({ id: "id_with_illegal/_char" });
                    assert_1.default.fail("Must throw if id has illegal characters");
                }
                catch (err) {
                    assert_1.default.equal("Id contains illegal chars.", err.message);
                }
            });
        });
        it("nativeAPI Should fail on contains '\\'", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                // Id shoudn't contain "\\".
                try {
                    yield client.databases.create({ id: "id_with_illegal\\_char" });
                    assert_1.default.fail("Must throw if id contains illegal characters");
                }
                catch (err) {
                    assert_1.default.equal("Id contains illegal chars.", err.message);
                }
            });
        });
        it("nativeAPI Should fail on contains '?'", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                // Id shoudn't contain "?".
                try {
                    yield client.databases.create({ id: "id_with_illegal?_?char" });
                    assert_1.default.fail("Must throw if id contains illegal characters");
                }
                catch (err) {
                    assert_1.default.equal("Id contains illegal chars.", err.message);
                }
            });
        });
        it("nativeAPI should fail on contains '#'", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                // Id shoudn't contain "#".
                try {
                    yield client.databases.create({ id: "id_with_illegal#_char" });
                    assert_1.default.fail("Must throw if id contains illegal characters");
                }
                catch (err) {
                    assert_1.default.equal("Id contains illegal chars.", err.message);
                }
            });
        });
    });
});
//# sourceMappingURL=database.spec.js.map