"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const routing_1 = require("../../routing");
describe("InMemoryCollectionRoutingMap Tests", function () {
    describe("getOverlappingRanges", function () {
        const partitionKeyRanges = [
            { id: "0", minInclusive: "", maxExclusive: "05C1C9CD673398" },
            {
                id: "1",
                minInclusive: "05C1C9CD673398",
                maxExclusive: "05C1D9CD673398"
            },
            {
                id: "2",
                minInclusive: "05C1D9CD673398",
                maxExclusive: "05C1E399CD6732"
            },
            {
                id: "3",
                minInclusive: "05C1E399CD6732",
                maxExclusive: "05C1E9CD673398"
            },
            { id: "4", minInclusive: "05C1E9CD673398", maxExclusive: "FF" }
        ];
        const partitionRangeWithInfo = partitionKeyRanges.map(r => [r, true]);
        const collectionRoutingMap = routing_1.CollectionRoutingMapFactory.createCompleteRoutingMap(partitionRangeWithInfo, "sample collection id");
        it("queryCompleteRange", function () {
            const completeRange = new routing_1.QueryRange("", "FF", true, false);
            const overlappingPartitionKeyRanges = collectionRoutingMap.getOverlappingRanges(completeRange);
            assert_1.default.equal(overlappingPartitionKeyRanges.length, partitionKeyRanges.length);
            assert_1.default.deepEqual(overlappingPartitionKeyRanges, partitionKeyRanges);
        });
        it("queryEmptyRange", function () {
            const emtpyRange = new routing_1.QueryRange("05C1C9CD673396", "05C1C9CD673396", true, false);
            const overlappingPartitionKeyRanges = collectionRoutingMap.getOverlappingRanges(emtpyRange);
            assert_1.default.equal(overlappingPartitionKeyRanges.length, 0);
        });
        it("queryPoint", function () {
            const pointRange = new routing_1.QueryRange("05C1D9CD673397", "05C1D9CD673397", true, true);
            const overlappingPartitionKeyRanges = collectionRoutingMap.getOverlappingRanges(pointRange);
            assert_1.default.equal(overlappingPartitionKeyRanges.length, 1);
            assert_1.default(overlappingPartitionKeyRanges[0].minInclusive <= pointRange.min);
            assert_1.default(overlappingPartitionKeyRanges[0].maxExclusive > pointRange.max);
        });
        it("boundaryPointQuery", function () {
            const pointRange = new routing_1.QueryRange("05C1C9CD673398", "05C1C9CD673398", true, true);
            const overlappingPartitionKeyRanges = collectionRoutingMap.getOverlappingRanges(pointRange);
            assert_1.default.equal(overlappingPartitionKeyRanges.length, 1);
            assert_1.default(overlappingPartitionKeyRanges[0].minInclusive <= pointRange.min);
            assert_1.default(overlappingPartitionKeyRanges[0].maxExclusive > pointRange.max);
            assert_1.default(overlappingPartitionKeyRanges[0].minInclusive === pointRange.min);
        });
    });
    describe("All methods", function () {
        const partitionRangeWithInfo = [
            [
                {
                    id: "2",
                    minInclusive: "0000000050",
                    maxExclusive: "0000000070"
                },
                2
            ],
            [
                {
                    id: "0",
                    minInclusive: "",
                    maxExclusive: "0000000030"
                },
                0
            ],
            [
                {
                    id: "1",
                    minInclusive: "0000000030",
                    maxExclusive: "0000000050"
                },
                1
            ],
            [
                {
                    id: "3",
                    minInclusive: "0000000070",
                    maxExclusive: "FF"
                },
                3
            ]
        ];
        const collectionRoutingMap = routing_1.CollectionRoutingMapFactory.createCompleteRoutingMap(partitionRangeWithInfo, "sample collection id");
        it("validate _orderedPartitionKeyRanges", function () {
            assert_1.default.equal("0", collectionRoutingMap.getOrderedParitionKeyRanges()[0].id);
            assert_1.default.equal("1", collectionRoutingMap.getOrderedParitionKeyRanges()[1].id);
            assert_1.default.equal("2", collectionRoutingMap.getOrderedParitionKeyRanges()[2].id);
            assert_1.default.equal("3", collectionRoutingMap.getOrderedParitionKeyRanges()[3].id);
        });
        // TODO: bad practice to test implementation details
        it("validate _orderedPartitionInfo", function () {
            assert_1.default.equal(0, collectionRoutingMap.orderedPartitionInfo[0]);
            assert_1.default.equal(1, collectionRoutingMap.orderedPartitionInfo[1]);
            assert_1.default.equal(2, collectionRoutingMap.orderedPartitionInfo[2]);
            assert_1.default.equal(3, collectionRoutingMap.orderedPartitionInfo[3]);
        });
        it("validate getRangeByEffectivePartitionKey", function () {
            assert_1.default.equal("0", collectionRoutingMap.getRangeByEffectivePartitionKey("").id);
            assert_1.default.equal("0", collectionRoutingMap.getRangeByEffectivePartitionKey("0000000000").id);
            assert_1.default.equal("1", collectionRoutingMap.getRangeByEffectivePartitionKey("0000000030").id);
            assert_1.default.equal("1", collectionRoutingMap.getRangeByEffectivePartitionKey("0000000031").id);
            assert_1.default.equal("3", collectionRoutingMap.getRangeByEffectivePartitionKey("0000000071").id);
        });
        // // TODO: bad practice to test implementation details
        // it("validate getRangeByPartitionKeyRangeId", function () {
        //     assert.equal("0", collectionRoutingMap.getRangeByPartitionKeyRangeId(0).id);
        //     assert.equal("1", collectionRoutingMap.getRangeByPartitionKeyRangeId(1).id);
        // });
        it("validate getOverlappingRanges", function () {
            const completeRange = new routing_1.QueryRange("", "FF", true, false);
            const compareId = function (a, b) {
                // TODO: any
                return a["id"] - b["id"];
            };
            const overlappingRanges = collectionRoutingMap.getOverlappingRanges([completeRange]).sort(compareId);
            assert_1.default.equal(4, overlappingRanges.length);
            let onlyParitionRanges = partitionRangeWithInfo.map(function (item) {
                return item[0];
            });
            onlyParitionRanges = onlyParitionRanges.sort(compareId);
            assert_1.default.deepEqual(overlappingRanges, onlyParitionRanges);
            const noPoint = new routing_1.QueryRange("", "", false, false);
            assert_1.default.equal(0, collectionRoutingMap.getOverlappingRanges([noPoint]).length);
            const onePoint = new routing_1.QueryRange("0000000040", "0000000040", true, true);
            let overlappingPartitionKeyRanges = collectionRoutingMap.getOverlappingRanges([onePoint]);
            assert_1.default.equal(1, overlappingPartitionKeyRanges.length);
            assert_1.default.equal("1", overlappingPartitionKeyRanges[0].id);
            const ranges = [
                new routing_1.QueryRange("0000000040", "0000000045", true, true),
                new routing_1.QueryRange("0000000045", "0000000046", true, true),
                new routing_1.QueryRange("0000000046", "0000000050", true, true)
            ];
            overlappingPartitionKeyRanges = collectionRoutingMap.getOverlappingRanges(ranges).sort(compareId);
            assert_1.default.equal(2, overlappingPartitionKeyRanges.length);
            assert_1.default.equal("1", overlappingPartitionKeyRanges[0].id);
            assert_1.default.equal("2", overlappingPartitionKeyRanges[1].id);
        });
    });
    describe("Error Handling", function () {
        describe("Incorrect instantiation", function () {
            it("Invalid Routing Map", function () {
                const partitionRangeWithInfo = [
                    [
                        {
                            id: "1",
                            minInclusive: "0000000020",
                            maxExclusive: "0000000030"
                        },
                        2
                    ],
                    [
                        {
                            id: "2",
                            minInclusive: "0000000025",
                            maxExclusive: "0000000035"
                        },
                        2
                    ]
                ];
                const collectionUniqueId = "";
                try {
                    const collectionRoutingMap = routing_1.CollectionRoutingMapFactory.createCompleteRoutingMap(partitionRangeWithInfo, "sample collection id");
                    assert_1.default.fail("must throw exception");
                }
                catch (e) {
                    assert_1.default.equal(e.message, "Ranges overlap");
                }
            });
            // TODO: test does two things (code smell)
            it("Incomplete Routing Map", function () {
                let partitionRangeWithInfo = [
                    [
                        {
                            id: "2",
                            minInclusive: "",
                            maxExclusive: "0000000030"
                        },
                        2
                    ],
                    [
                        {
                            id: "3",
                            minInclusive: "0000000031",
                            maxExclusive: "FF"
                        },
                        2
                    ]
                ];
                let collectionRoutingMap = routing_1.CollectionRoutingMapFactory.createCompleteRoutingMap(partitionRangeWithInfo, "sample collection id");
                assert_1.default.equal(collectionRoutingMap, null);
                partitionRangeWithInfo = [
                    [
                        {
                            id: "2",
                            minInclusive: "",
                            maxExclusive: "0000000030"
                        },
                        2
                    ],
                    [
                        {
                            id: "2",
                            minInclusive: "0000000030",
                            maxExclusive: "FF"
                        },
                        2
                    ]
                ];
                collectionRoutingMap = routing_1.CollectionRoutingMapFactory.createCompleteRoutingMap(partitionRangeWithInfo, "sample collection id");
                assert_1.default.notEqual(collectionRoutingMap, null);
            });
        });
    });
});
//# sourceMappingURL=inMemoryCollectionRoutingMap.spec.js.map