"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const __1 = require("../..");
const documents_1 = require("../../documents");
const TestHelpers_1 = require("../common/TestHelpers");
const doc = { id: "myId", pk: "pk" };
describe("ResourceLink Trimming of leading and trailing slashes", function () {
    this.timeout(process.env.MOCHA_TIMEOUT || 10000);
    const containerId = "testcontainer";
    beforeEach(function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield TestHelpers_1.removeAllDatabases();
        });
    });
    it("validate correct execution of query using named container link with leading and trailing slashes", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const containerDefinition = {
                id: containerId,
                partitionKey: {
                    paths: ["/pk"],
                    kind: documents_1.PartitionKind.Hash
                }
            };
            const containerOptions = { offerThroughput: 10100 };
            const container = yield TestHelpers_1.getTestContainer("validate correct execution of query", undefined, containerDefinition, containerOptions);
            yield container.items.create(doc);
            const query = "SELECT * from " + containerId;
            const queryOptions = { partitionKey: "pk" };
            const queryIterator = container.items.query(query, queryOptions);
            const { result } = yield queryIterator.toArray();
            assert_1.default.equal(result[0]["id"], "myId");
        });
    });
});
describe("Test Query Metrics On Single Partition Collection", function () {
    this.timeout(process.env.MOCHA_TIMEOUT || 20000);
    const collectionId = "testCollection2";
    const testQueryMetricsOnSinglePartition = function (document) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const database = yield TestHelpers_1.getTestDatabase("query metrics test db");
                const collectionDefinition = { id: collectionId };
                const collectionOptions = { offerThroughput: 4000 };
                const { body: createdCollectionDef } = yield database.containers.create(collectionDefinition, collectionOptions);
                const createdContainer = database.container(createdCollectionDef.id);
                yield createdContainer.items.create(document);
                const collectionLink = "/dbs/" + database.id + "/colls/" + collectionId + "/";
                const query = "SELECT * from " + collectionId;
                const queryOptions = { populateQueryMetrics: true };
                const queryIterator = createdContainer.items.query(query, queryOptions);
                while (queryIterator.hasMoreResults()) {
                    const { result: results, headers } = yield queryIterator.executeNext();
                    if (results === undefined) {
                        // no more results
                        break;
                    }
                    assert_1.default.notEqual(headers[__1.Constants.HttpHeaders.QueryMetrics]["0"], null);
                }
            }
            catch (err) {
                throw err;
            }
        });
    };
    afterEach(function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield TestHelpers_1.removeAllDatabases();
        });
    });
    beforeEach(function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield TestHelpers_1.removeAllDatabases();
        });
    });
    it("validate that query metrics are correct for a single partition query", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield testQueryMetricsOnSinglePartition(doc);
        });
    });
});
//# sourceMappingURL=query.spec.js.map