"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const range_1 = require("../../range");
describe("RangePartitionResolver", function () {
    describe("constructor", function () {
        // TODO: should split these up into individual tests
        it("missing partitionKeyExtractor throws", function () {
            const expetcedError = /Error: partitionKeyExtractor cannot be null or undefined/;
            assert_1.default.throws(function () {
                const r = new range_1.RangePartitionResolver(undefined, undefined);
            }, expetcedError);
            assert_1.default.throws(function () {
                const r = new range_1.RangePartitionResolver(undefined, undefined);
            }, expetcedError);
            assert_1.default.throws(function () {
                const r = new range_1.RangePartitionResolver(null, undefined);
            }, expetcedError);
        });
        it("invalid partitionKeyExtractor throws", function () {
            const expetcedError = /partitionKeyExtractor must be either a 'string' or a 'function'/;
            assert_1.default.throws(function () {
                const r = new range_1.RangePartitionResolver(0, undefined);
            }, expetcedError);
            assert_1.default.throws(function () {
                const r = new range_1.RangePartitionResolver(true, undefined);
            }, expetcedError);
            assert_1.default.throws(function () {
                const r = new range_1.RangePartitionResolver(NaN, undefined);
            }, expetcedError);
            assert_1.default.throws(function () {
                const r = new range_1.RangePartitionResolver([], undefined);
            }, expetcedError);
            assert_1.default.throws(function () {
                const r = new range_1.RangePartitionResolver({}, undefined);
            }, expetcedError);
        });
        it("missing partitionKeyMap throws", function () {
            const expectedError = /Error: partitionKeyMap cannot be null or undefined/;
            assert_1.default.throws(function () {
                const r = new range_1.RangePartitionResolver("", undefined);
            }, expectedError);
            assert_1.default.throws(function () {
                const r = new range_1.RangePartitionResolver(function () {
                    /* no op */
                }, undefined);
            }, expectedError);
            assert_1.default.throws(function () {
                const r = new range_1.RangePartitionResolver("", null);
            }, expectedError);
        });
        it("invalid partitionKeyMap throws", function () {
            const expectedError = /Error: partitionKeyMap has to be an Array/;
            assert_1.default.throws(function () {
                const r = new range_1.RangePartitionResolver("", 0);
            }, expectedError);
            assert_1.default.throws(function () {
                const r = new range_1.RangePartitionResolver("", "");
            }, expectedError);
            assert_1.default.throws(function () {
                const r = new range_1.RangePartitionResolver("", true);
            }, expectedError);
            assert_1.default.throws(function () {
                const r = new range_1.RangePartitionResolver("", NaN);
            }, expectedError);
            assert_1.default.throws(function () {
                const r = new range_1.RangePartitionResolver("", {});
            }, expectedError);
            const rpr = new range_1.RangePartitionResolver("", new Array());
        });
        it("valid RangePartitionResolver", function (done) {
            const resolver = new range_1.RangePartitionResolver("", []);
            assert_1.default(resolver);
            assert_1.default.strictEqual(resolver.partitionKeyExtractor, "");
            assert_1.default.deepEqual(resolver.partitionKeyMap, []);
            done();
        });
    });
    describe("getFirstContainingMapEntryOrNull", function () {
        it("getFirstContainingMapEntryOrNull - empty map returns null", function (done) {
            const ranges = [undefined, null, 0, "", true, [], {}, NaN, new range_1.Range()];
            const resolver = new range_1.RangePartitionResolver("", []);
            ranges.forEach(function (r) {
                const result = resolver.getFirstContainingMapEntryOrNull(r);
                assert_1.default.equal(result, null);
            });
            done();
        });
        it("_tryGetContainingRange - map with no containing entry returns null", function (done) {
            const mapEntry = { range: new range_1.Range({ low: "A" }), link: "link1" };
            const resolver = new range_1.RangePartitionResolver("key", [mapEntry]);
            const result = resolver.getFirstContainingMapEntryOrNull(new range_1.Range({ low: "B" }));
            assert_1.default.equal(result, null);
            done();
        });
        it("_tryGetContainingRange - map with single containing entry returns entry", function (done) {
            const mapEntry = { range: new range_1.Range(), link: "link1" };
            const resolver = new range_1.RangePartitionResolver("key", [mapEntry]);
            const result = resolver.getFirstContainingMapEntryOrNull(new range_1.Range());
            assert_1.default.deepEqual(result, { range: new range_1.Range(), link: "link1" });
            done();
        });
        it("_tryGetContainingRange - map with more multiple containing entries returns first entry", function (done) {
            const map1 = [
                { range: new range_1.Range({ low: "A", high: "B" }), link: "link1" },
                { range: new range_1.Range({ low: "A" }), link: "link2" }
            ];
            const resolver1 = new range_1.RangePartitionResolver("key", map1);
            const result1 = resolver1.getFirstContainingMapEntryOrNull(new range_1.Range({ low: "A" }));
            assert_1.default.strictEqual(result1.link, "link1");
            const map2 = [
                { range: new range_1.Range({ low: "A" }), link: "link2" },
                { range: new range_1.Range({ low: "A", high: "Z" }), link: "link1" }
            ];
            const resolver2 = new range_1.RangePartitionResolver("key", map2);
            const result2 = resolver2.getFirstContainingMapEntryOrNull(new range_1.Range({ low: "A" }));
            assert_1.default.strictEqual(result2.link, "link2");
            done();
        });
    });
    describe("resolveForCreate", function () {
        it("_tryGetContainingRange - map containing parition key returns corresponding link", function (done) {
            const resolver = new range_1.RangePartitionResolver("key", [
                { range: new range_1.Range({ low: "A", high: "M" }), link: "link1" },
                { range: new range_1.Range({ low: "N", high: "Z" }), link: "link2" }
            ]);
            const result = resolver.resolveForCreate("X");
            assert_1.default.strictEqual(result, "link2");
            done();
        });
        it("_tryGetContainingRange - map not containing parition key throws", function (done) {
            const resolver = new range_1.RangePartitionResolver("key", [
                { range: new range_1.Range({ low: "A", high: "M" }), link: "link1" }
            ]);
            assert_1.default.throws(function () {
                const result = resolver.resolveForCreate("X");
            }, /Error: Invalid operation: A containing range for 'X,X' doesn't exist in the partition map./);
            done();
        });
    });
    const resolveForReadTest = function (resolver, partitionKey, expectedLinks) {
        const result = resolver.resolveForRead(partitionKey);
        assert_1.default.deepEqual(expectedLinks, result);
    };
    describe("resolveForRead", function () {
        const resolver = new range_1.RangePartitionResolver(function (doc) {
            // TODO: any
            return doc.key;
        }, [
            {
                range: new range_1.Range({ low: "A", high: "M" }),
                link: "link1"
            },
            {
                range: new range_1.Range({ low: "N", high: "Z" }),
                link: "link2"
            }
        ]);
        it("undefined", function (done) {
            const partitionKey = undefined;
            const expectedLinks = ["link1", "link2"];
            resolveForReadTest(resolver, partitionKey, expectedLinks);
            done();
        });
        it("null", function (done) {
            const partitionKey = null;
            const expectedLinks = ["link1", "link2"];
            resolveForReadTest(resolver, partitionKey, expectedLinks);
            done();
        });
    });
    describe("resolveForRead string", function () {
        const resolver = new range_1.RangePartitionResolver(function (doc) {
            // TODO: any
            return doc.key;
        }, [
            {
                range: new range_1.Range({ low: "A", high: "M" }),
                link: "link1"
            },
            {
                range: new range_1.Range({ low: "N", high: "Z" }),
                link: "link2"
            }
        ]);
        it("point", function (done) {
            const partitionKey = new range_1.Range({ low: "D" });
            const expectedLinks = ["link1"];
            resolveForReadTest(resolver, partitionKey, expectedLinks);
            const partitionKey2 = new range_1.Range({ low: "Q" });
            const expectedLinks2 = ["link2"];
            resolveForReadTest(resolver, partitionKey2, expectedLinks2);
            done();
        });
        it("range", function (done) {
            const partitionKey = new range_1.Range({ low: "D", high: "Q" });
            const expectedLinks = ["link1", "link2"];
            resolveForReadTest(resolver, partitionKey, expectedLinks);
            done();
        });
        it("array of ranges", function (done) {
            const partitionKey = [new range_1.Range({ low: "A", high: "B" }), new range_1.Range({ low: "Q" })];
            const expectedLinks = ["link1", "link2"];
            resolveForReadTest(resolver, partitionKey, expectedLinks);
            done();
        });
    });
    describe("resolveForRead number", function () {
        const partitionKeyExtractor = function (doc) {
            return doc.key;
        };
        const partitionKeyMap = [
            {
                range: new range_1.Range({ low: 1, high: 15 }),
                link: "link1"
            },
            {
                range: new range_1.Range({ low: 16, high: 30 }),
                link: "link2"
            }
        ];
        it("point, default compareFunction", function (done) {
            const resolver = new range_1.RangePartitionResolver(partitionKeyExtractor, partitionKeyMap);
            const partitionKey = new range_1.Range({ low: 2 });
            const expectedLinks = ["link2"];
            resolveForReadTest(resolver, partitionKey, expectedLinks);
            done();
        });
        it("point, custom compareFunction", function (done) {
            const resolver = new range_1.RangePartitionResolver(partitionKeyExtractor, partitionKeyMap, function (a, b) {
                return a - b;
            });
            const partitionKey = new range_1.Range({ low: 2 });
            const expectedLinks = ["link1"];
            resolveForReadTest(resolver, partitionKey, expectedLinks);
            done();
        });
    });
    describe("compareFunction", function () {
        const invalidCompareFunctionTest = function (compareFunction) {
            assert_1.default.throws(function () {
                const resolver = new range_1.RangePartitionResolver("key", [{ range: new range_1.Range({ low: "A" }), link: "link1" }], compareFunction);
            }, /Invalid argument: 'compareFunction' is not a function/);
        };
        it("invalid compareFunction - null", function () {
            const compareFunction = null;
            invalidCompareFunctionTest(compareFunction);
        });
        it("invalid compareFunction - string", function () {
            const compareFunction = "";
            invalidCompareFunctionTest(compareFunction);
        });
        it("invalid compareFunction - number", function () {
            const compareFunction = 0;
            invalidCompareFunctionTest(compareFunction);
        });
        it("invalid compareFunction - boolean", function () {
            const compareFunction = false;
            invalidCompareFunctionTest(compareFunction);
        });
        it("invalid compareFunction - object", function () {
            const compareFunction = {};
            invalidCompareFunctionTest(compareFunction);
        });
        it("compareFunction throws", function () {
            const resolver = new range_1.RangePartitionResolver("key", [{ range: new range_1.Range({ low: "A" }), link: "link1" }], function (a, b) {
                throw new Error("Compare error");
            });
            assert_1.default.throws(function () {
                const result = resolver.resolveForRead("A", ["link1"]); // TODO: any
            }, /Error: Compare error/);
        });
    });
});
//# sourceMappingURL=rangePartitionResolver.spec.js.map