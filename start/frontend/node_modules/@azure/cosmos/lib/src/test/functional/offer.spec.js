"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const __1 = require("../..");
const _testConfig_1 = require("../common/_testConfig");
const TestHelpers_1 = require("../common/TestHelpers");
const client = new __1.CosmosClient({ endpoint: _testConfig_1.endpoint, auth: { masterKey: _testConfig_1.masterKey } });
const validateOfferResponseBody = function (offer) {
    assert_1.default(offer.id, "Id cannot be null");
    assert_1.default(offer._rid, "Resource Id (Rid) cannot be null");
    assert_1.default(offer._self, "Self Link cannot be null");
    assert_1.default(offer.resource, "Resource Link cannot be null");
    assert_1.default(offer._self.indexOf(offer.id) !== -1, "Offer id not contained in offer self link.");
};
describe("NodeJS CRUD Tests", function () {
    this.timeout(process.env.MOCHA_TIMEOUT || 10000);
    beforeEach(function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.timeout(process.env.MOCHA_TIMEOUT || 10000);
            yield TestHelpers_1.removeAllDatabases();
        });
    });
    describe("Validate Offer CRUD", function () {
        it("nativeApi Should do offer read and query operations successfully name based single partition collection", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const mbInBytes = 1024 * 1024;
                const offerThroughput = 400;
                const container = yield TestHelpers_1.getTestContainer("Validate Offer CRUD");
                const { headers } = yield container.read({ populateQuotaInfo: true });
                // Validate the collection size quota
                assert_1.default.notEqual(headers[__1.Constants.HttpHeaders.MaxResourceQuota], null);
                assert_1.default.notEqual(headers[__1.Constants.HttpHeaders.MaxResourceQuota], "");
                const collectionSize = Number(headers[__1.Constants.HttpHeaders.MaxResourceQuota].split(";").reduce((map, obj) => {
                    const items = obj.split("=");
                    map[items[0]] = items[1];
                    return map;
                }, {})[__1.Constants.Quota.CollectionSize]);
                assert_1.default.equal(collectionSize, 10 * mbInBytes, "Collection size is unexpected");
                const { result: offers } = yield client.offers.readAll().toArray();
                assert_1.default.equal(offers.length, 1);
                const expectedOffer = offers[0];
                assert_1.default.equal(expectedOffer.content.offerThroughput, offerThroughput, "Expected offerThroughput to be " + offerThroughput);
                validateOfferResponseBody(expectedOffer);
                // Read the offer
                const { body: readOffer } = yield client.offer(expectedOffer.id).read();
                validateOfferResponseBody(readOffer);
                // Check if the read offer is what we expected.
                assert_1.default.equal(expectedOffer.id, readOffer.id);
                assert_1.default.equal(expectedOffer._rid, readOffer._rid);
                assert_1.default.equal(expectedOffer._self, readOffer._self);
                assert_1.default.equal(expectedOffer.resource, readOffer.resource);
                // Query for offer.
                const querySpec = {
                    query: "select * FROM root r WHERE r.id=@id",
                    parameters: [
                        {
                            name: "@id",
                            value: expectedOffer.id
                        }
                    ]
                };
                const { result: offers2 } = yield client.offers.query(querySpec).toArray();
                assert_1.default.equal(offers2.length, 1);
                const oneOffer = offers2[0];
                validateOfferResponseBody(oneOffer);
                // Now delete the collection.
                yield container.delete();
                // read offer after deleting collection.
                try {
                    yield client.offer(expectedOffer.id).read();
                    assert_1.default.fail("Must throw after delete");
                }
                catch (err) {
                    const notFoundErrorCode = 404;
                    assert_1.default.equal(err.code, notFoundErrorCode, "response should return error code 404");
                }
            });
        });
        it("nativeApi Should do offer replace operations successfully name based", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const container = yield TestHelpers_1.getTestContainer("Validate Offer CRUD");
                const { result: offers } = yield client.offers.readAll().toArray();
                assert_1.default.equal(offers.length, 1);
                const expectedOffer = offers[0];
                validateOfferResponseBody(expectedOffer);
                // Replace the offer.
                const offerToReplace = Object.assign({}, expectedOffer);
                const oldThroughput = offerToReplace.content.offerThroughput;
                offerToReplace.content.offerThroughput = oldThroughput + 100;
                const { body: replacedOffer } = yield client.offer(offerToReplace.id).replace(offerToReplace);
                validateOfferResponseBody(replacedOffer);
                // Check if the replaced offer is what we expect.
                assert_1.default.equal(replacedOffer.id, offerToReplace.id);
                assert_1.default.equal(replacedOffer._rid, offerToReplace._rid);
                assert_1.default.equal(replacedOffer._self, offerToReplace._self);
                assert_1.default.equal(replacedOffer.resource, offerToReplace.resource);
                assert_1.default.equal(replacedOffer.content.offerThroughput, offerToReplace.content.offerThroughput);
                // Replace an offer with a bad id.
                try {
                    const offerBadId = Object.assign({}, offerToReplace);
                    offerBadId._rid = "NotAllowed";
                    yield client.offer(offerBadId._self).replace(offerBadId);
                    assert_1.default.fail("Must throw after replace with bad id");
                }
                catch (err) {
                    const badRequestErrorCode = 400;
                    assert_1.default.equal(err.code, badRequestErrorCode);
                }
            });
        });
    });
});
//# sourceMappingURL=offer.spec.js.map