"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const __1 = require("../..");
const _testConfig_1 = require("../common/_testConfig");
const TestHelpers_1 = require("../common/TestHelpers");
describe("NodeJS CRUD Tests", function () {
    this.timeout(process.env.MOCHA_TIMEOUT || 10000);
    beforeEach(function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield TestHelpers_1.removeAllDatabases();
        });
    });
    describe("Validate Authorization", function () {
        it("should handle all the key options", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const clientOptionsKey = new __1.CosmosClient({ endpoint: _testConfig_1.endpoint, key: _testConfig_1.masterKey });
                assert_1.default(undefined !== (yield clientOptionsKey.databases.readAll().toArray()), "Should be able to fetch list of databases");
                const clientOptionsAuthKey = new __1.CosmosClient({ endpoint: _testConfig_1.endpoint, auth: { key: _testConfig_1.masterKey } });
                assert_1.default(undefined !== (yield clientOptionsAuthKey.databases.readAll().toArray()), "Should be able to fetch list of databases");
                const clientOptionsAuthMasterKey = new __1.CosmosClient({ endpoint: _testConfig_1.endpoint, auth: { masterKey: _testConfig_1.masterKey } });
                assert_1.default(undefined !== (yield clientOptionsAuthMasterKey.databases.readAll().toArray()), "Should be able to fetch list of databases");
            });
        });
        const setupEntities = function (isUpsertTest) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                // create database
                const database = yield TestHelpers_1.getTestDatabase("Validate Authorization database");
                // create container1
                const { body: container1 } = yield database.containers.create({ id: "Validate Authorization container" });
                // create document1
                const { body: document1 } = yield database
                    .container(container1.id)
                    .items.create({ id: "coll1doc1", foo: "bar", key: "value" });
                // create document 2
                const { body: document2 } = yield database
                    .container(container1.id)
                    .items.create({ id: "coll1doc2", foo: "bar2", key: "value2" });
                // create container 2
                const { body: container2 } = yield database.containers.create({ id: "sample container2" });
                // create user1
                const { body: user1 } = yield database.users.create({ id: "user1" });
                let permission = {
                    id: "permission On Coll1",
                    permissionMode: __1.DocumentBase.PermissionMode.Read,
                    resource: container1._self
                }; // TODO: any rid stuff
                // create permission for container1
                const { body: permissionOnColl1 } = yield TestHelpers_1.createOrUpsertPermission(database.user(user1.id), permission, undefined, isUpsertTest);
                assert_1.default(permissionOnColl1._token !== undefined, "permission token is invalid");
                permission = {
                    id: "permission On Doc1",
                    permissionMode: __1.DocumentBase.PermissionMode.All,
                    resource: document2._self // TODO: any rid
                };
                // create permission for document 2
                const { body: permissionOnDoc2 } = yield TestHelpers_1.createOrUpsertPermission(database.user(user1.id), permission, undefined, isUpsertTest);
                assert_1.default(permissionOnDoc2._token !== undefined, "permission token is invalid"); // TODO: any rid
                // create user 2
                const { body: user2 } = yield database.users.create({ id: "user2" });
                permission = {
                    id: "permission On coll2",
                    permissionMode: __1.DocumentBase.PermissionMode.All,
                    resource: container2._self // TODO: any rid
                };
                // create permission on container 2
                const { body: permissionOnColl2 } = yield TestHelpers_1.createOrUpsertPermission(database.user(user2.id), permission, undefined, isUpsertTest);
                const entities = {
                    database,
                    coll1: container1,
                    coll2: container2,
                    doc1: document1,
                    doc2: document2,
                    user1,
                    user2,
                    permissionOnColl1,
                    permissionOnDoc2,
                    permissionOnColl2
                };
                return entities;
            });
        };
        const authorizationCRUDTest = function (isUpsertTest) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    const badclient = new __1.CosmosClient({ endpoint: _testConfig_1.endpoint, auth: undefined });
                    const { result: databases } = yield badclient.databases.readAll().toArray();
                    assert_1.default.fail("Must fail");
                }
                catch (err) {
                    assert_1.default(err !== undefined, "error should not be undefined");
                    const unauthorizedErrorCode = 401;
                    assert_1.default.equal(err.code, unauthorizedErrorCode, "error code should be equal to 401");
                }
                // setup entities
                // TODO: should move this out of this test and into before/etc.
                const entities = yield setupEntities(isUpsertTest);
                const resourceTokens = {};
                resourceTokens[entities.coll1.id] = entities.permissionOnColl1._token;
                resourceTokens[entities.doc1.id] = entities.permissionOnColl1._token;
                const col1Client = new __1.CosmosClient({ endpoint: _testConfig_1.endpoint, auth: { resourceTokens } });
                // 1. Success-- Use Col1 Permission to Read
                const { body: successColl1 } = yield col1Client
                    .database(entities.database.id)
                    .container(entities.coll1.id)
                    .read();
                assert_1.default(successColl1 !== undefined, "error reading container");
                // 2. Failure-- Use Col1 Permission to delete
                try {
                    yield col1Client
                        .database(entities.database.id)
                        .container(entities.coll1.id)
                        .delete();
                    assert_1.default.fail("must fail if no permission");
                }
                catch (err) {
                    assert_1.default(err !== undefined, "expected to fail, no permission to delete");
                    assert_1.default.equal(err.code, 403, "Must return a code for not authorized");
                }
                // 3. Success-- Use Col1 Permission to Read All Docs
                const { result: successDocuments } = yield col1Client
                    .database(entities.database.id)
                    .container(entities.coll1.id)
                    .items.readAll()
                    .toArray();
                assert_1.default(successDocuments !== undefined, "error reading documents");
                assert_1.default.equal(successDocuments.length, 2, "Expected 2 Documents to be succesfully read");
                // 4. Success-- Use Col1 Permission to Read Col1Doc1
                const { body: successDoc } = yield col1Client
                    .database(entities.database.id)
                    .container(entities.coll1.id)
                    .item(entities.doc1.id)
                    .read();
                assert_1.default(successDoc !== undefined, "error reading document");
                assert_1.default.equal(successDoc.id, entities.doc1.id, "Expected to read children using parent permissions");
                // TODO: Permission Feed uses RID right now
                /*
                      const col2Client = new CosmosClient({
                          endpoint,
                          auth: { permissionFeed: [entities.permissionOnColl2] },
                      });
                      const doc = { id: "new doc", CustomProperty1: "BBBBBB", customProperty2: 1000 };
                      const col2Container = await col2Client.databaseDatabase(entities.db.id)
                          .containerContainer(entities.coll2.id);
                      const { result: successDoc2 } = await createOrUpsertItem(
                          col2Container, doc, undefined, isUpsertTest);
                      assert(successDoc2 !== undefined, "error creating document");
                      assert.equal(successDoc2.CustomProperty1, doc.CustomProperty1,
                          "document should have been created successfully");
                      */
            });
        };
        const authorizationCRUDOverMultiplePartitionsTest = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                // create database
                // create container
                const partitionKey = "key";
                const containerDefinition = {
                    id: "coll1",
                    partitionKey: { paths: ["/" + partitionKey], kind: __1.DocumentBase.PartitionKind.Hash }
                };
                const container = yield TestHelpers_1.getTestContainer("authorization CRUD multiple partitons", undefined, containerDefinition);
                // create user
                const { body: userDef } = yield container.database.users.create({ id: "user1" });
                const user = container.database.user(userDef.id);
                const key = 1;
                const permissionDefinition = {
                    id: "permission1",
                    permissionMode: __1.DocumentBase.PermissionMode.All,
                    resource: container.url,
                    resourcePartitionKey: [key]
                };
                // create permission
                const { body: permission } = yield user.permissions.create(permissionDefinition);
                assert_1.default(permission._token !== undefined, "permission token is invalid");
                const resourceTokens = {};
                resourceTokens[container.id] = permission._token;
                const restrictedClient = new __1.CosmosClient({ endpoint: _testConfig_1.endpoint, auth: { resourceTokens } });
                yield restrictedClient
                    .database(container.database.id)
                    .container(container.id)
                    .items.create({ id: "document1", key: 1 });
                try {
                    yield restrictedClient
                        .database(container.database.id)
                        .container(container.id)
                        .items.create({ id: "document2", key: 2 });
                    assert_1.default.fail("Must throw unauthorized on read");
                }
                catch (err) {
                    const unauthorizedErrorCode = 403;
                    assert_1.default.equal(err.code, unauthorizedErrorCode);
                }
            });
        };
        it("nativeApi Should do authorization successfully name based", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield authorizationCRUDTest(false);
            });
        });
        it("nativeApi Should do authorization successfully name based with upsert", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield authorizationCRUDTest(true);
            });
        });
        it("nativeApi Should do authorization over multiple partitions successfully name based", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield authorizationCRUDOverMultiplePartitionsTest();
            });
        });
    });
});
//# sourceMappingURL=authorization.spec.js.map