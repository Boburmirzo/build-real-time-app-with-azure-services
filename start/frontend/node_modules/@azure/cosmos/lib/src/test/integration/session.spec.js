"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const sinon = tslib_1.__importStar(require("sinon"));
const __1 = require("../..");
const common_1 = require("../../common");
const documents_1 = require("../../documents");
const _testConfig_1 = require("../common/_testConfig");
const TestHelpers_1 = require("../common/TestHelpers");
// TODO: there is alot of "any" types for tokens here
// TODO: there is alot of leaky document client stuff here that will make removing document client hard
const client = new __1.CosmosClient({
    endpoint: _testConfig_1.endpoint,
    auth: { masterKey: _testConfig_1.masterKey },
    consistencyLevel: documents_1.ConsistencyLevel.Session
});
function getCollection2TokenMap(sessionContainer) {
    return sessionContainer.collectionResourceIdToSessionTokens;
}
describe("Session Token", function () {
    this.timeout(process.env.MOCHA_TIMEOUT || 20000);
    const containerId = "sessionTestColl";
    const containerDefinition = {
        id: containerId,
        partitionKey: { paths: ["/id"], kind: documents_1.PartitionKind.Hash }
    };
    const containerOptions = { offerThroughput: 25100 };
    const clientContext = client.clientContext;
    const requestHandler = clientContext.requestHandler;
    const sessionContainer = clientContext.sessionContainer;
    const getSpy = sinon.spy(requestHandler, "get");
    const postSpy = sinon.spy(requestHandler, "post");
    const putSpy = sinon.spy(requestHandler, "put");
    const deleteSpy = sinon.spy(requestHandler, "delete");
    beforeEach(function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield TestHelpers_1.removeAllDatabases();
        });
    });
    it("validate session tokens for sequence of operations", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const database = yield TestHelpers_1.getTestDatabase("session test", client);
            const { body: createdContainerDef } = yield database.containers.create(containerDefinition, containerOptions);
            const container = database.container(createdContainerDef.id);
            assert_1.default.equal(postSpy.lastCall.args[3][__1.Constants.HttpHeaders.SessionToken], undefined);
            // TODO: testing implementation detail by looking at containerResourceIdToSesssionTokens
            let collRid2SessionToken = sessionContainer
                .collectionResourceIdToSessionTokens;
            assert_1.default.equal(collRid2SessionToken.size, 0, "Should have no tokens in container");
            const { body: document1 } = yield container.items.create({ id: "1" });
            assert_1.default.equal(postSpy.lastCall.args[3][__1.Constants.HttpHeaders.SessionToken], undefined, "Initial create token should be qual");
            collRid2SessionToken = getCollection2TokenMap(sessionContainer);
            assert_1.default.equal(collRid2SessionToken.size, 1, "Should only have one container in the sessioncontainer");
            const containerRid = collRid2SessionToken.keys().next().value;
            let containerTokens = collRid2SessionToken.get(containerRid);
            assert_1.default.equal(containerTokens.size, 1, "Should only have one partition in container");
            const firstPartition = containerTokens.keys().next().value;
            let firstPartitionToken = containerTokens.get(firstPartition);
            assert_1.default.notEqual(firstPartitionToken, "Should have a token for first partition");
            const token = sessionContainer.get({
                isNameBased: true,
                operationType: "create",
                resourceAddress: container.url,
                resourceType: "docs",
                resourceId: "2"
            });
            const { body: document2 } = yield container.items.create({ id: "2" });
            assert_1.default.equal(postSpy.lastCall.args[3][__1.Constants.HttpHeaders.SessionToken], token, "create token should be equal");
            collRid2SessionToken = getCollection2TokenMap(sessionContainer);
            assert_1.default.equal(collRid2SessionToken.size, 1, "Should only have one container in the sessioncontainer");
            containerTokens = collRid2SessionToken.get(containerRid);
            assert_1.default.equal(containerTokens.size, 2, "Should have two partitions in container");
            const keysIterator = containerTokens.keys();
            keysIterator.next(); // partition 1
            const secondPartition = keysIterator.next().value;
            assert_1.default.equal(containerTokens.get(firstPartition).toString(), firstPartitionToken.toString(), "First partition token should still match after create");
            let secondPartitionToken = containerTokens.get(secondPartition);
            assert_1.default(secondPartitionToken, "Should have a LSN for second partition");
            const readToken = sessionContainer.get({
                isNameBased: true,
                operationType: "read",
                resourceAddress: container.url,
                resourceType: "docs",
                resourceId: "1"
            });
            yield container.item(document1.id, "1").read();
            assert_1.default.equal(getSpy.lastCall.args[2][__1.Constants.HttpHeaders.SessionToken], readToken, "read token should be equal");
            collRid2SessionToken = getCollection2TokenMap(sessionContainer);
            assert_1.default.equal(collRid2SessionToken.size, 1, "Should only have one container in the sessioncontainer");
            containerTokens = collRid2SessionToken.get(containerRid);
            assert_1.default.equal(containerTokens.size, 2, "Should have two partitions in container");
            assert_1.default.equal(containerTokens.get(firstPartition).toString(), firstPartitionToken.toString(), "First partition token should still match after read");
            assert_1.default.equal(containerTokens.get(secondPartition).toString(), secondPartitionToken.toString(), "Second partition token should still match after read");
            const upsertToken = sessionContainer.get({
                isNameBased: true,
                operationType: "upsert",
                resourceAddress: container.url,
                resourceType: "docs",
                resourceId: "1"
            });
            const { body: document13 } = yield container.items.upsert({ id: "1", operation: "upsert" }, { partitionKey: "1" });
            assert_1.default.equal(postSpy.lastCall.args[3][__1.Constants.HttpHeaders.SessionToken], upsertToken, "upsert token should be equal");
            collRid2SessionToken = getCollection2TokenMap(sessionContainer);
            assert_1.default.equal(collRid2SessionToken.size, 1, "Should only have one container in the sessioncontainer");
            containerTokens = collRid2SessionToken.get(containerRid);
            assert_1.default.equal(containerTokens.size, 2, "Should have two partitions in container");
            // TODO: should validate the LSN only increased by 1...
            assert_1.default.notEqual(containerTokens.get(firstPartition).toString(), firstPartitionToken.toString(), "First partition token should no longer match after upsert");
            assert_1.default.equal(containerTokens.get(secondPartition).toString(), secondPartitionToken.toString(), "Second partition token should still match after upsert");
            firstPartitionToken = containerTokens.get(firstPartition);
            const deleteToken = sessionContainer.get({
                isNameBased: true,
                operationType: "delete",
                resourceAddress: container.url,
                resourceType: "docs",
                resourceId: "2"
            });
            yield container.item(document2.id, "2").delete();
            assert_1.default.equal(deleteSpy.lastCall.args[2][__1.Constants.HttpHeaders.SessionToken], deleteToken, "delete token should be equal");
            collRid2SessionToken = getCollection2TokenMap(sessionContainer);
            assert_1.default.equal(collRid2SessionToken.size, 1, "Should only have one container in the sessioncontainer");
            containerTokens = collRid2SessionToken.get(containerRid);
            assert_1.default.equal(containerTokens.size, 2, "Should have two partitions in container");
            assert_1.default.equal(containerTokens.get(firstPartition).toString(), firstPartitionToken.toString(), "First partition token should still match delete");
            // TODO: should validate the LSN only increased by 1...
            assert_1.default.notEqual(containerTokens.get(secondPartition).toString(), secondPartitionToken.toString(), "Second partition token should not match after delete");
            secondPartitionToken = containerTokens.get(secondPartition);
            const replaceToken = sessionContainer.get({
                isNameBased: true,
                operationType: "replace",
                resourceAddress: container.url,
                resourceType: "docs",
                resourceId: "1"
            });
            yield container.item(document13.id).replace({ id: "1", operation: "replace" }, { partitionKey: "1" });
            assert_1.default.equal(putSpy.lastCall.args[3][__1.Constants.HttpHeaders.SessionToken], replaceToken, "replace token should be equal");
            collRid2SessionToken = getCollection2TokenMap(sessionContainer);
            assert_1.default.equal(collRid2SessionToken.size, 1, "Should only have one container in the sessioncontainer");
            containerTokens = collRid2SessionToken.get(containerRid);
            assert_1.default.equal(containerTokens.size, 2, "Should have two partitions in container");
            // TODO: should validate the LSN only increased by 1...
            assert_1.default.notEqual(containerTokens.get(firstPartition).toString(), firstPartitionToken.toString(), "First partition token should no longer match after replace");
            assert_1.default.equal(containerTokens.get(secondPartition).toString(), secondPartitionToken.toString(), "Second partition token should still match after replace");
            firstPartitionToken = containerTokens.get(firstPartition);
            const query = "SELECT * from " + containerId;
            const queryOptions = { partitionKey: "1" };
            const queryIterator = container.items.query(query, queryOptions);
            const queryToken = sessionContainer.get({
                isNameBased: true,
                operationType: "query",
                resourceAddress: container.url,
                resourceType: "docs"
            });
            yield queryIterator.toArray();
            assert_1.default.equal(postSpy.lastCall.args[3][__1.Constants.HttpHeaders.SessionToken], queryToken);
            collRid2SessionToken = getCollection2TokenMap(sessionContainer);
            assert_1.default.equal(collRid2SessionToken.size, 1, "Should only have one container in the sessioncontainer");
            containerTokens = collRid2SessionToken.get(containerRid);
            assert_1.default.equal(containerTokens.size, 2, "Should have two partitions in container");
            assert_1.default.equal(containerTokens.get(firstPartition).toString(), firstPartitionToken.toString(), "First partition token should still match after query");
            assert_1.default.equal(containerTokens.get(secondPartition).toString(), secondPartitionToken.toString(), "Second partition token should still match after query");
            const deleteContainerToken = sessionContainer.get({
                isNameBased: true,
                operationType: "delete",
                resourceAddress: container.url,
                resourceType: "container",
                resourceId: container.id
            });
            yield container.delete();
            assert_1.default.equal(deleteSpy.lastCall.args[2][__1.Constants.HttpHeaders.SessionToken], deleteContainerToken, "delete container token should match");
            collRid2SessionToken = getCollection2TokenMap(sessionContainer);
            assert_1.default.equal(collRid2SessionToken.size, 0, "collRid map should be empty on container delete");
            getSpy.restore();
            postSpy.restore();
            deleteSpy.restore();
            putSpy.restore();
        });
    });
    it("validate 'lsn not caught up' error for higher lsn and clearing session token", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.retries(2);
            const database = yield TestHelpers_1.getTestDatabase("session test", client);
            const containerLink = "dbs/" + database.id + "/colls/" + containerId;
            const increaseLSN = function (oldTokens) {
                for (const [coll, tokens] of oldTokens.entries()) {
                    for (const [pk, token] of tokens.entries()) {
                        token.globalLsn = token.globalLsn + 200;
                        const newToken = token.merge(token);
                        return `0:${newToken.toString()}`;
                    }
                }
                throw new Error("No valid token found to increase");
            };
            yield database.containers.create(containerDefinition, containerOptions);
            const container = database.container(containerDefinition.id);
            const { headers } = yield container.items.create({ id: "1" });
            const callbackSpy = sinon.spy(function (path, reqHeaders) {
                const oldTokens = getCollection2TokenMap(sessionContainer);
                reqHeaders[__1.Constants.HttpHeaders.SessionToken] = increaseLSN(oldTokens);
            });
            const applySessionTokenStub = sinon.stub(clientContext, "applySessionToken").callsFake(callbackSpy);
            try {
                yield container.item("1").read({ partitionKey: "1" });
                assert_1.default.fail("readDocument must throw");
            }
            catch (err) {
                assert_1.default.equal(err.substatus, 1002, "Substatus should indicate the LSN didn't catchup.");
                assert_1.default.equal(callbackSpy.callCount, 1);
                assert_1.default.equal(common_1.Helper.trimSlashes(callbackSpy.lastCall.args[0]), containerLink + "/docs/1");
            }
            finally {
                applySessionTokenStub.restore();
            }
            yield container.item("1").read({ partitionKey: "1" });
        });
    });
    // TODO: chrande - looks like this might be broken by going name based?
    // We never had a name based version of this test. Looks like we fail to set the session token
    // because OwnerId is missing on the header. This only happens for name based.
    it.skip("client should not have session token of a container created by another client", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const client2 = new __1.CosmosClient({
                endpoint: _testConfig_1.endpoint,
                auth: { masterKey: _testConfig_1.masterKey },
                consistencyLevel: documents_1.ConsistencyLevel.Session
            });
            const database = yield TestHelpers_1.getTestDatabase("clientshouldnothaveanotherclienttoken");
            yield database.containers.create(containerDefinition, containerOptions);
            const container = database.container(containerDefinition.id);
            yield container.read();
            yield client2
                .database(database.id)
                .container(containerDefinition.id)
                .delete();
            yield client2.database(database.id).containers.create(containerDefinition, containerOptions);
            yield client2
                .database(database.id)
                .container(containerDefinition.id)
                .read();
            assert_1.default.equal(client.clientContext.getSessionToken(container.url), ""); // TODO: _self
            assert_1.default.notEqual(client2.clientContext.getSessionToken(container.url), "");
        });
    });
    it("validate session container update on 'Not found' with 'undefined' status code for non master resource", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const client2 = new __1.CosmosClient({
                endpoint: _testConfig_1.endpoint,
                auth: { masterKey: _testConfig_1.masterKey },
                consistencyLevel: documents_1.ConsistencyLevel.Session
            });
            const db = yield TestHelpers_1.getTestDatabase("session test", client);
            const { body: createdContainerDef } = yield db.containers.create(containerDefinition, containerOptions);
            const createdContainer = db.container(createdContainerDef.id);
            const { body: createdDocument } = yield createdContainer.items.create({
                id: "1"
            });
            const requestOptions = { partitionKey: "1" };
            yield client2
                .database(db.id)
                .container(createdContainerDef.id)
                .item(createdDocument.id)
                .delete(requestOptions);
            const setSessionTokenSpy = sinon.spy(sessionContainer, "set");
            try {
                yield createdContainer.item(createdDocument.id).read(requestOptions);
                assert_1.default.fail("Must throw");
            }
            catch (err) {
                assert_1.default.equal(err.code, 404, "expecting 404 (Not found)");
                assert_1.default.equal(err.substatus, undefined, "expecting substatus code to be undefined");
                assert_1.default.equal(setSessionTokenSpy.callCount, 1, "unexpected number of calls to sesSessionToken");
            }
            finally {
                setSessionTokenSpy.restore();
            }
        });
    });
});
//# sourceMappingURL=session.spec.js.map