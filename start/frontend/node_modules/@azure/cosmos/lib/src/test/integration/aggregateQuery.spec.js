"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const util = tslib_1.__importStar(require("util"));
const documents_1 = require("../../documents");
const TestData_1 = require("../common/TestData");
const TestHelpers_1 = require("../common/TestHelpers");
// process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";
describe("NodeJS Aggregate Query Tests", function () {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        this.timeout(process.env.MOCHA_TIMEOUT || 20000);
        const partitionKey = "key";
        const uniquePartitionKey = "uniquePartitionKey";
        const testdata = new TestData_1.TestData(partitionKey, uniquePartitionKey);
        const documentDefinitions = testdata.docs;
        let db;
        let container;
        const containerDefinition = {
            id: "sample container",
            indexingPolicy: {
                includedPaths: [
                    {
                        path: "/",
                        indexes: [
                            {
                                kind: documents_1.IndexKind.Hash,
                                dataType: documents_1.DataType.String
                            },
                            {
                                kind: documents_1.IndexKind.Range,
                                dataType: documents_1.DataType.Number
                            }
                        ]
                    }
                ]
            },
            partitionKey: {
                paths: ["/" + partitionKey],
                kind: documents_1.PartitionKind.Hash
            }
        };
        const containerOptions = { offerThroughput: 10100 };
        describe("Validate Aggregate Document Query", function () {
            // - removes all the databases,
            //  - creates a new database,
            //      - creates a new collecton,
            //          - bulk inserts documents to the container
            before(function () {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    yield TestHelpers_1.removeAllDatabases();
                    container = yield TestHelpers_1.getTestContainer("Validate Aggregate Document Query", undefined, containerDefinition, containerOptions);
                    db = container.database;
                    yield TestHelpers_1.bulkInsertItems(container, documentDefinitions);
                });
            });
            const validateResult = function (actualValue, expectedValue) {
                assert_1.default.deepEqual(actualValue, expectedValue, "actual value doesn't match with expected value.");
            };
            const validateToArray = function (queryIterator, expectedResults) {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    try {
                        const { result: results } = yield queryIterator.toArray();
                        assert_1.default.equal(results.length, expectedResults.length, "invalid number of results");
                        assert_1.default.equal(queryIterator.hasMoreResults(), false, "hasMoreResults: no more results is left");
                    }
                    catch (err) {
                        throw err;
                    }
                });
            };
            const validateNextItem = function (queryIterator, expectedResults) {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    let results = [];
                    try {
                        while (results.length < expectedResults.length) {
                            const { result: item } = yield queryIterator.nextItem();
                            if (item === undefined) {
                                assert_1.default(!queryIterator.hasMoreResults(), "hasMoreResults must signal results exhausted");
                                validateResult(results, expectedResults);
                                return;
                            }
                            results = results.concat(item);
                            if (results.length < expectedResults.length) {
                                assert_1.default(queryIterator.hasMoreResults(), "hasMoreResults must indicate more results");
                            }
                        }
                    }
                    catch (err) {
                        throw err;
                    }
                });
            };
            const validateNextItemAndCurrentAndHasMoreResults = function (queryIterator, expectedResults) {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    // curent and nextItem recursively invoke each other till queryIterator is exhausted
                    ////////////////////////////////
                    // validate nextItem()
                    ////////////////////////////////
                    const results = [];
                    try {
                        while (results.length <= expectedResults.length) {
                            const { result: item } = yield queryIterator.nextItem();
                            const { result: currentItem } = yield queryIterator.current();
                            if (item === undefined) {
                                break;
                            }
                            results.push(item);
                            if (results.length < expectedResults.length) {
                                assert_1.default(queryIterator.hasMoreResults(), "hasMoreResults must indicate more results");
                            }
                            assert_1.default.equal(item, currentItem, "current must give the previously item returned by nextItem");
                        }
                        assert_1.default(!queryIterator.hasMoreResults(), "hasMoreResults must signal results exhausted");
                        validateResult(results, expectedResults);
                    }
                    catch (err) {
                        throw err;
                    }
                });
            };
            const validateExecuteNextAndHasMoreResults = function (queryIterator, options, expectedResults) {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    ////////////////////////////////
                    // validate executeNext()
                    ////////////////////////////////
                    const pageSize = options["maxItemCount"];
                    const listOfResultPages = [];
                    const listOfHeaders = [];
                    let totalFetchedResults = [];
                    try {
                        while (totalFetchedResults.length <= expectedResults.length) {
                            const { result: results, headers } = yield queryIterator.executeNext();
                            listOfResultPages.push(results);
                            listOfHeaders.push(headers);
                            if (results === undefined || totalFetchedResults.length === expectedResults.length) {
                                break;
                            }
                            totalFetchedResults = totalFetchedResults.concat(results);
                            if (totalFetchedResults.length < expectedResults.length) {
                                // there are more results
                                assert_1.default(results.length <= pageSize, "executeNext: invalid fetch block size");
                                assert_1.default.equal(results.length, pageSize, "executeNext: invalid fetch block size");
                                assert_1.default(queryIterator.hasMoreResults(), "hasMoreResults expects to return true");
                            }
                            else {
                                // no more results
                                assert_1.default.equal(expectedResults.length, totalFetchedResults.length, "executeNext: didn't fetch all the results");
                                assert_1.default(results.length <= pageSize, "executeNext: actual fetch size is more than the requested page size");
                            }
                        }
                        // no more results
                        validateResult(totalFetchedResults, expectedResults);
                        assert_1.default.equal(queryIterator.hasMoreResults(), false, "hasMoreResults: no more results is left");
                    }
                    catch (err) {
                        throw err;
                    }
                });
            };
            const validateForEach = function (queryIterator, expectedResults) {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    ////////////////////////////////
                    // validate forEach()
                    ////////////////////////////////
                    var e_1, _a;
                    const results = [];
                    let callbackSingnalledEnd = false;
                    try {
                        // forEach uses callbacks still, so just wrap in a promise
                        for (var _b = tslib_1.__asyncValues(queryIterator.getAsyncIterator()), _c; _c = yield _b.next(), !_c.done;) {
                            const { result: item } = _c.value;
                            // if the previous invocation returned false, forEach must avoid invoking the callback again!
                            assert_1.default.equal(callbackSingnalledEnd, false, "forEach called callback after the first false returned");
                            results.push(item);
                            if (results.length === expectedResults.length) {
                                callbackSingnalledEnd = true;
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    validateResult(results, expectedResults);
                });
            };
            const executeQueryAndValidateResults = function (query, expectedResults) {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const options = { enableCrossPartitionQuery: true, maxDegreeOfParallelism: 2, maxItemCount: 1 };
                    const queryIterator = container.items.query(query, options);
                    yield validateToArray(queryIterator, expectedResults);
                    queryIterator.reset();
                    yield validateExecuteNextAndHasMoreResults(queryIterator, options, expectedResults);
                    queryIterator.reset();
                    yield validateNextItemAndCurrentAndHasMoreResults(queryIterator, expectedResults);
                    yield validateForEach(queryIterator, expectedResults);
                });
            };
            const generateTestConfigs = function () {
                const testConfigs = [];
                const aggregateQueryFormat = "SELECT VALUE %s(r.%s) FROM r WHERE %s";
                const aggregateOrderByQueryFormat = "SELECT VALUE %s(r.%s) FROM r WHERE %s ORDER BY r.%s";
                const aggregateConfigs = [
                    {
                        operator: "AVG",
                        expected: testdata.sum / testdata.numberOfDocumentsWithNumbericId,
                        condition: util.format("IS_NUMBER(r.%s)", partitionKey)
                    },
                    { operator: "AVG", expected: undefined, condition: "true" },
                    {
                        operator: "COUNT",
                        expected: testdata.numberOfDocuments,
                        condition: "true"
                    },
                    { operator: "MAX", expected: "xyz", condition: "true" },
                    { operator: "MIN", expected: null, condition: "true" },
                    {
                        operator: "SUM",
                        expected: testdata.sum,
                        condition: util.format("IS_NUMBER(r.%s)", partitionKey)
                    },
                    { operator: "SUM", expected: undefined, condition: "true" }
                ];
                aggregateConfigs.forEach(function (config) {
                    let query = util.format(aggregateQueryFormat, config.operator, partitionKey, config.condition);
                    let testName = util.format("%s %s", config.operator, config.condition);
                    testConfigs.push({
                        testName,
                        query,
                        expected: config.expected
                    });
                    query = util.format(aggregateOrderByQueryFormat, config.operator, partitionKey, config.condition, partitionKey);
                    testName = util.format("%s %s OrderBy", config.operator, config.condition);
                    testConfigs.push({
                        testName,
                        query,
                        expected: config.expected
                    });
                });
                const aggregateSinglePartitionQueryFormat = "SELECT VALUE %s(r.%s) FROM r WHERE r.%s = '%s'";
                const aggregateSinglePartitionQueryFormatSelect = "SELECT %s(r.%s) FROM r WHERE r.%s = '%s'";
                const samePartitionSum = (testdata.numberOfDocsWithSamePartitionKey * (testdata.numberOfDocsWithSamePartitionKey + 1)) / 2.0;
                const aggregateSinglePartitionConfigs = [
                    {
                        operator: "AVG",
                        expected: samePartitionSum / testdata.numberOfDocsWithSamePartitionKey
                    },
                    {
                        operator: "COUNT",
                        expected: testdata.numberOfDocsWithSamePartitionKey
                    },
                    {
                        operator: "MAX",
                        expected: testdata.numberOfDocsWithSamePartitionKey
                    },
                    { operator: "MIN", expected: 1 },
                    { operator: "SUM", expected: samePartitionSum }
                ];
                aggregateSinglePartitionConfigs.forEach(function (config) {
                    let query = util.format(aggregateSinglePartitionQueryFormat, config.operator, testdata.field, partitionKey, uniquePartitionKey);
                    let testName = util.format("%s SinglePartition %s", config.operator, "SELECT VALUE");
                    testConfigs.push({
                        testName,
                        query,
                        expected: config.expected
                    });
                    query = util.format(aggregateSinglePartitionQueryFormatSelect, config.operator, testdata.field, partitionKey, uniquePartitionKey);
                    testName = util.format("%s SinglePartition %s", config.operator, "SELECT");
                    testConfigs.push({
                        testName,
                        query,
                        expected: { $1: config.expected }
                    });
                });
                return testConfigs;
            };
            generateTestConfigs().forEach(function (test) {
                it(test.testName, function () {
                    return tslib_1.__awaiter(this, void 0, void 0, function* () {
                        try {
                            const expected = test.expected === undefined ? [] : [test.expected];
                            yield executeQueryAndValidateResults(test.query, expected);
                        }
                        catch (err) {
                            throw err;
                        }
                    });
                });
            });
        });
    });
});
//# sourceMappingURL=aggregateQuery.spec.js.map