"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const __1 = require("../..");
const documents_1 = require("../../documents");
const TestHelpers_1 = require("../common/TestHelpers");
describe("NodeJS CRUD Tests", function () {
    this.timeout(process.env.MOCHA_TIMEOUT || 10000);
    beforeEach(function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield TestHelpers_1.removeAllDatabases();
        });
    });
    describe("Validate Container CRUD", function () {
        const containerCRUDTest = function (hasPartitionKey) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    // create database
                    const database = yield TestHelpers_1.getTestDatabase("Validate Container CRUD");
                    // create a container
                    const containerDefinition = {
                        id: "sample container",
                        indexingPolicy: { indexingMode: documents_1.IndexingMode.consistent }
                    };
                    if (hasPartitionKey) {
                        containerDefinition.partitionKey = { paths: ["/id"], kind: __1.DocumentBase.PartitionKind.Hash };
                    }
                    const { body: containerDef } = yield database.containers.create(containerDefinition);
                    const container = database.container(containerDef.id);
                    assert_1.default.equal(containerDefinition.id, containerDef.id);
                    assert_1.default.equal("consistent", containerDef.indexingPolicy.indexingMode);
                    if (containerDef.partitionKey) {
                        assert_1.default.equal(containerDef.partitionKey.kind, containerDefinition.partitionKey.kind);
                        assert_1.default.deepEqual(containerDef.partitionKey.paths, containerDefinition.partitionKey.paths);
                    }
                    // read containers after creation
                    const { result: containers } = yield database.containers.readAll().toArray();
                    assert_1.default.equal(containers.length, 1, "create should increase the number of containers");
                    // query containers
                    const querySpec = {
                        query: "SELECT * FROM root r WHERE r.id=@id",
                        parameters: [
                            {
                                name: "@id",
                                value: containerDefinition.id
                            }
                        ]
                    };
                    const { result: results } = yield database.containers.query(querySpec).toArray();
                    assert_1.default(results.length > 0, "number of results for the query should be > 0");
                    const { result: ranges } = yield container.readPartitionKeyRanges().toArray();
                    assert_1.default(ranges.length > 0, "container should have at least 1 partition");
                    // Replacing indexing policy is allowed.
                    containerDef.indexingPolicy.indexingMode = documents_1.IndexingMode.lazy;
                    const { body: replacedContainer } = yield container.replace(containerDef);
                    assert_1.default.equal("lazy", replacedContainer.indexingPolicy.indexingMode);
                    // Replacing partition key is not allowed.
                    try {
                        containerDef.partitionKey = { paths: ["/key"], kind: __1.DocumentBase.PartitionKind.Hash };
                        yield container.replace(containerDef);
                        assert_1.default.fail("Replacing paritionkey must throw");
                    }
                    catch (err) {
                        const badRequestErrorCode = 400;
                        assert_1.default.equal(err.code, badRequestErrorCode, "response should return error code " + badRequestErrorCode);
                    }
                    finally {
                        containerDef.partitionKey = containerDefinition.partitionKey; // Resume partition key
                    }
                    // Replacing id is not allowed.
                    try {
                        containerDef.id = "try_to_replace_id";
                        yield container.replace(containerDef);
                        assert_1.default.fail("Replacing container id must throw");
                    }
                    catch (err) {
                        const notFoundErrorCode = 400;
                        assert_1.default.equal(err.code, notFoundErrorCode, "response should return error code 404");
                    }
                    // read container
                    containerDef.id = containerDefinition.id; // Resume Id.
                    const { body: readcontainer } = yield container.read();
                    assert_1.default.equal(containerDefinition.id, readcontainer.id);
                    // delete container
                    yield container.delete();
                    // read container after deletion
                    try {
                        yield container.read();
                        assert_1.default.fail("Must fail to read container after delete");
                    }
                    catch (err) {
                        const notFoundErrorCode = 404;
                        assert_1.default.equal(err.code, notFoundErrorCode, "response should return error code 404");
                    }
                }
                catch (err) {
                    throw err;
                }
            });
        };
        const badPartitionKeyDefinitionTest = function (isNameBased) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    // create database
                    const database = yield TestHelpers_1.getTestDatabase("container CRUD bad partition key");
                    // create a container
                    const badPartitionKeyDefinition = {
                        paths: "/id",
                        kind: __1.DocumentBase.PartitionKind.Hash
                    };
                    const containerDefinition = {
                        id: "sample container",
                        indexingPolicy: { indexingMode: documents_1.IndexingMode.consistent },
                        partitionKey: badPartitionKeyDefinition // This is invalid, forced using type coersion
                    };
                    try {
                        yield database.containers.create(containerDefinition);
                    }
                    catch (err) {
                        assert_1.default.equal(err.code, 400);
                    }
                }
                catch (err) {
                    throw err;
                }
            });
        };
        it("nativeApi Should do container CRUD operations successfully name based", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    yield containerCRUDTest(false);
                }
                catch (err) {
                    throw err;
                }
            });
        });
        it("nativeApi Should do elastic container CRUD operations successfully name based", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    yield containerCRUDTest(true);
                }
                catch (err) {
                    throw err;
                }
            });
        });
        it("nativeApi container with bad partition key definition name based", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    yield badPartitionKeyDefinitionTest(true);
                }
                catch (err) {
                    throw err;
                }
            });
        });
        it("nativeApi container with bad partition key definition name based", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    yield badPartitionKeyDefinitionTest(false);
                }
                catch (err) {
                    throw err;
                }
            });
        });
    });
    describe("Validate container indexing policy", function () {
        it("nativeApi Should create container with correct indexing policy name based", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                // create database
                const database = yield TestHelpers_1.getTestDatabase("container test database");
                // create container
                const { body: containerDef } = yield database.containers.create({ id: "container test container" });
                const container = database.container(containerDef.id);
                assert_1.default.equal(containerDef.indexingPolicy.indexingMode, __1.DocumentBase.IndexingMode.consistent, "default indexing mode should be consistent");
                yield container.delete();
                const lazyContainerDefinition = {
                    id: "lazy container",
                    indexingPolicy: { indexingMode: __1.DocumentBase.IndexingMode.lazy }
                };
                const { body: lazyContainerDef } = yield database.containers.create(lazyContainerDefinition);
                const lazyContainer = database.container(lazyContainerDef.id);
                assert_1.default.equal(lazyContainerDef.indexingPolicy.indexingMode, __1.DocumentBase.IndexingMode.lazy, "indexing mode should be lazy");
                yield lazyContainer.delete();
                const uniqueKeysContainerDefinition = {
                    id: "uniqueKeysContainer",
                    uniqueKeyPolicy: { uniqueKeys: [{ paths: ["/foo"] }] }
                };
                const { body: uniqueKeysContainerDef } = yield database.containers.create(uniqueKeysContainerDefinition);
                const uniqueKeysContainer = database.container(uniqueKeysContainerDef.id);
                assert_1.default.equal(uniqueKeysContainerDef.uniqueKeyPolicy.uniqueKeys[0].paths, "/foo");
                yield uniqueKeysContainer.delete();
                const consistentcontainerDefinition = {
                    id: "lazy container",
                    indexingPolicy: { indexingMode: "consistent" } // tests the type flexibility
                };
                const { body: consistentContainerDef } = yield database.containers.create(consistentcontainerDefinition);
                const consistentContainer = database.container(consistentContainerDef.id);
                assert_1.default.equal(containerDef.indexingPolicy.indexingMode, __1.DocumentBase.IndexingMode.consistent, "indexing mode should be consistent");
                yield consistentContainer.delete();
                const containerDefinition = {
                    id: "containerWithIndexingPolicy",
                    indexingPolicy: {
                        automatic: true,
                        indexingMode: __1.DocumentBase.IndexingMode.consistent,
                        includedPaths: [
                            {
                                path: "/",
                                indexes: [
                                    {
                                        kind: __1.DocumentBase.IndexKind.Hash,
                                        dataType: __1.DocumentBase.DataType.Number,
                                        precision: 2
                                    }
                                ]
                            }
                        ],
                        excludedPaths: [
                            {
                                path: '/"systemMetadata"/*'
                            }
                        ]
                    }
                };
                const { body: containerWithIndexingPolicyDef } = yield database.containers.create(containerDefinition);
                // Two included paths.
                assert_1.default.equal(1, containerWithIndexingPolicyDef.indexingPolicy.includedPaths.length, "Unexpected includedPaths length");
                // The first included path is what we created.
                assert_1.default.equal("/", containerWithIndexingPolicyDef.indexingPolicy.includedPaths[0].path);
                // Backend adds a default index
                assert_1.default(containerWithIndexingPolicyDef.indexingPolicy.includedPaths[0].indexes.length > 1);
                assert_1.default.equal(__1.DocumentBase.IndexKind.Range, containerWithIndexingPolicyDef.indexingPolicy.includedPaths[0].indexes[0].kind);
                // The second included path is a timestamp index created by the server.
                // And two excluded paths.
                assert_1.default.equal(2, containerWithIndexingPolicyDef.indexingPolicy.excludedPaths.length, "Unexpected excludedPaths length");
                assert_1.default.equal('/"systemMetadata"/*', containerWithIndexingPolicyDef.indexingPolicy.excludedPaths[0].path);
            });
        });
        const checkDefaultIndexingPolicyPaths = function (indexingPolicy) {
            assert_1.default.equal(1, indexingPolicy["excludedPaths"].length);
            assert_1.default.equal(1, indexingPolicy["includedPaths"].length);
            let rootIncludedPath = null;
            if (indexingPolicy["includedPaths"][0]["path"] === "/*") {
                rootIncludedPath = indexingPolicy["includedPaths"][0];
            }
            assert_1.default(rootIncludedPath); // root path should exist.
            // In the root path, there should be two indexes. One for Strings and one for Numbers.
            assert_1.default.equal(2, rootIncludedPath["indexes"].length);
        };
        const defaultIndexingPolicyTest = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    // create database
                    const database = yield TestHelpers_1.getTestDatabase("container test database");
                    // create container with no indexing policy specified.
                    const containerDefinition01 = { id: "TestCreateDefaultPolicy01" };
                    const { body: containerNoIndexPolicyDef } = yield database.containers.create(containerDefinition01);
                    checkDefaultIndexingPolicyPaths(containerNoIndexPolicyDef["indexingPolicy"]);
                    // create container with partial policy specified.
                    const containerDefinition02 = {
                        id: "TestCreateDefaultPolicy02",
                        indexingPolicy: {
                            indexingMode: documents_1.IndexingMode.lazy,
                            automatic: true
                        }
                    };
                    const { body: containerWithPartialPolicyDef } = yield database.containers.create(containerDefinition02);
                    checkDefaultIndexingPolicyPaths(containerWithPartialPolicyDef["indexingPolicy"]);
                    // create container with default policy.
                    const containerDefinition03 = {
                        id: "TestCreateDefaultPolicy03",
                        indexingPolicy: {}
                    };
                    const { body: containerDefaultPolicy } = yield database.containers.create(containerDefinition03);
                    checkDefaultIndexingPolicyPaths(containerDefaultPolicy["indexingPolicy"]);
                    // create container with indexing policy missing indexes.
                    const containerDefinition04 = {
                        id: "TestCreateDefaultPolicy04",
                        indexingPolicy: {
                            includedPaths: [
                                {
                                    path: "/*"
                                }
                            ]
                        }
                    };
                    const { body: containerMissingIndexes } = yield database.containers.create(containerDefinition04);
                    checkDefaultIndexingPolicyPaths(containerMissingIndexes["indexingPolicy"]);
                    // create container with indexing policy missing precision.
                    const containerDefinition05 = {
                        id: "TestCreateDefaultPolicy05",
                        indexingPolicy: {
                            includedPaths: [
                                {
                                    path: "/*",
                                    indexes: [
                                        {
                                            kind: documents_1.IndexKind.Hash,
                                            dataType: documents_1.DataType.String
                                        },
                                        {
                                            kind: documents_1.IndexKind.Range,
                                            dataType: documents_1.DataType.Number
                                        }
                                    ]
                                }
                            ]
                        }
                    };
                    const { body: containerMissingPrecision } = yield database.containers.create(containerDefinition05);
                    checkDefaultIndexingPolicyPaths(containerMissingPrecision["indexingPolicy"]);
                }
                catch (err) {
                    throw err;
                }
            });
        };
        it("nativeApi Should create container with default indexing policy name based", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    yield defaultIndexingPolicyTest();
                }
                catch (err) {
                    throw err;
                }
            });
        });
    });
    describe("Validate response headers", function () {
        const createThenReadcontainer = function (database, body) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    const { body: createdcontainer, headers } = yield database.containers.create(body);
                    const response = yield database.container(createdcontainer.id).read();
                    return response;
                }
                catch (err) {
                    throw err;
                }
            });
        };
        const indexProgressHeadersTest = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    const database = yield TestHelpers_1.getTestDatabase("Validate response headers");
                    const { headers: headers1 } = yield createThenReadcontainer(database, { id: "consistent_coll" });
                    assert_1.default.notEqual(headers1[__1.Constants.HttpHeaders.IndexTransformationProgress], undefined);
                    assert_1.default.equal(headers1[__1.Constants.HttpHeaders.LazyIndexingProgress], undefined);
                    const lazyContainerDefinition = {
                        id: "lazy_coll",
                        indexingPolicy: { indexingMode: __1.DocumentBase.IndexingMode.lazy }
                    };
                    const { headers: headers2 } = yield createThenReadcontainer(database, lazyContainerDefinition);
                    assert_1.default.notEqual(headers2[__1.Constants.HttpHeaders.IndexTransformationProgress], undefined);
                    assert_1.default.notEqual(headers2[__1.Constants.HttpHeaders.LazyIndexingProgress], undefined);
                    const noneContainerDefinition = {
                        id: "none_coll",
                        indexingPolicy: { indexingMode: __1.DocumentBase.IndexingMode.none, automatic: false }
                    };
                    const { headers: headers3 } = yield createThenReadcontainer(database, noneContainerDefinition);
                    assert_1.default.notEqual(headers3[__1.Constants.HttpHeaders.IndexTransformationProgress], undefined);
                    assert_1.default.equal(headers3[__1.Constants.HttpHeaders.LazyIndexingProgress], undefined);
                }
                catch (err) {
                    throw err;
                }
            });
        };
        it("nativeApi Validate index progress headers name based", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    yield indexProgressHeadersTest();
                }
                catch (err) {
                    throw err;
                }
            });
        });
    });
});
describe("containers.createIfNotExists", function () {
    let database;
    before(function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // create database
            database = yield TestHelpers_1.getTestDatabase("containers.createIfNotExists");
        });
    });
    it("should handle container does not exist", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const def = { id: "does not exist" };
            const { container } = yield database.containers.createIfNotExists(def);
            const { body: readDef } = yield container.read();
            assert_1.default.equal(def.id, readDef.id);
        });
    });
    it("should handle container exists", function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const def = { id: "does exist" };
            yield database.containers.create(def);
            const { container } = yield database.containers.createIfNotExists(def);
            const { body: readDef } = yield container.read();
            assert_1.default.equal(def.id, readDef.id);
        });
    });
});
//# sourceMappingURL=container.spec.js.map