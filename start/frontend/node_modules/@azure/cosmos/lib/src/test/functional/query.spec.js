"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const __1 = require("../..");
const _testConfig_1 = require("../common/_testConfig");
const TestHelpers_1 = require("../common/TestHelpers");
const client = new __1.CosmosClient({ endpoint: _testConfig_1.endpoint, auth: { masterKey: _testConfig_1.masterKey } });
// TODO: This is required for Node 6 and above, so just putting it in here.
// Might want to decide on only supporting async iterators once Node supports them officially.
if (!Symbol || !Symbol.asyncIterator) {
    Symbol.asyncIterator = Symbol.for("Symbol.asyncIterator");
}
describe("NodeJS CRUD Tests", function () {
    this.timeout(process.env.MOCHA_TIMEOUT || 10000);
    before(function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield TestHelpers_1.removeAllDatabases();
        });
    });
    describe("Validate Queries CRUD", function () {
        const queriesCRUDTest = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    // create a database
                    const database = yield TestHelpers_1.getTestDatabase("query test database");
                    // query databases
                    const querySpec0 = {
                        query: "SELECT * FROM root r WHERE r.id=@id",
                        parameters: [
                            {
                                name: "@id",
                                value: database.id
                            }
                        ]
                    };
                    const { result: results } = yield client.databases.query(querySpec0).toArray();
                    assert_1.default(results.length > 0, "number of results for the query should be > 0");
                    const querySpec1 = {
                        query: "SELECT * FROM root r WHERE r.id='" + database.id + "'"
                    };
                    const { result: results2 } = yield client.databases.query(querySpec1).toArray();
                    assert_1.default(results2.length > 0, "number of results for the query should be > 0");
                    const querySpec2 = "SELECT * FROM root r WHERE r.id='" + database.id + "'";
                    const { result: results3 } = yield client.databases.query(querySpec2).toArray();
                    assert_1.default(results3.length > 0, "number of results for the query should be > 0");
                }
                catch (err) {
                    throw err;
                }
            });
        };
        it("nativeApi Should do queries CRUD operations successfully name based", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    yield queriesCRUDTest();
                }
                catch (err) {
                    throw err;
                }
            });
        });
    });
    describe("Validate QueryIterator Functionality For Multiple Partition container", function () {
        const documentDefinitions = [
            { id: "document1" },
            { id: "document2", key: null, prop: 1 },
            { id: "document3", key: false, prop: 1 },
            { id: "document4", key: true, prop: 1 },
            { id: "document5", key: 1, prop: 1 },
            { id: "document6", key: "A", prop: 1 }
        ];
        let container;
        // creates a new database, creates a new collecton, bulk inserts documents to the container
        beforeEach(function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const partitionKey = "key";
                const containerDefinition = {
                    id: "coll1",
                    partitionKey: {
                        paths: ["/" + partitionKey],
                        kind: __1.DocumentBase.PartitionKind.Hash
                    }
                };
                const containerOptions = { offerThroughput: 12000 };
                container = yield TestHelpers_1.getTestContainer("query CRUD database 中文", client, containerDefinition, containerOptions);
                yield TestHelpers_1.bulkInsertItems(container, documentDefinitions);
            });
        });
        it("nativeApi validate QueryIterator nextItem on Multiple Partition Colleciton", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                // obtain an instance of queryIterator
                const queryIterator = container.items.readAll();
                let cnt = 0;
                while (queryIterator.hasMoreResults()) {
                    const { result } = yield queryIterator.nextItem();
                    if (result === undefined) {
                        break;
                    }
                    cnt++;
                }
                assert_1.default.equal(cnt, documentDefinitions.length);
            });
        });
    });
    describe("Validate QueryIterator Functionality", function () {
        this.timeout(process.env.MOCHA_TIMEOUT || 30000);
        let resources;
        beforeEach(function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const container = yield TestHelpers_1.getTestContainer("Validate QueryIterator Functionality", client);
                const { body: doc1 } = yield container.items.create({ id: "doc1", prop1: "value1" });
                const { body: doc2 } = yield container.items.create({ id: "doc2", prop1: "value2" });
                const { body: doc3 } = yield container.items.create({ id: "doc3", prop1: "value3" });
                resources = { container, doc1, doc2, doc3 };
            });
        });
        const queryIteratorToArrayTest = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const queryIterator = resources.container.items.readAll({ maxItemCount: 2 });
                const { result: docs } = yield queryIterator.toArray();
                assert_1.default.equal(docs.length, 3, "queryIterator should return all documents using continuation");
                assert_1.default.equal(docs[0].id, resources.doc1.id);
                assert_1.default.equal(docs[1].id, resources.doc2.id);
                assert_1.default.equal(docs[2].id, resources.doc3.id);
            });
        };
        const queryIteratorAsyncIteratorTest = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                var e_1, _a;
                const queryIterator = resources.container.items.readAll({ maxItemCount: 2 });
                let counter = 0;
                try {
                    for (var _b = tslib_1.__asyncValues(queryIterator.getAsyncIterator()), _c; _c = yield _b.next(), !_c.done;) {
                        const { result: doc } = _c.value;
                        counter++;
                        if (counter === 1) {
                            assert_1.default.equal(doc.id, resources.doc1.id, "first document should be doc1");
                        }
                        else if (counter === 2) {
                            assert_1.default.equal(doc.id, resources.doc2.id, "second document should be doc2");
                        }
                        else if (counter === 3) {
                            assert_1.default.equal(doc.id, resources.doc3.id, "third document should be doc3");
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                assert_1.default(counter === 3, "iterator should have run 3 times");
            });
        };
        const queryIteratorForEachTest = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const queryIterator = resources.container.items.readAll({ maxItemCount: 2 });
                let counter = 0;
                yield queryIterator.forEach((item, headers, index) => {
                    counter++;
                    if (index === 0) {
                        assert_1.default.equal(item.id, resources.doc1.id, "first document should be doc1");
                    }
                    else if (index === 1) {
                        assert_1.default.equal(item.id, resources.doc2.id, "second document should be doc2");
                    }
                    else if (index === 2) {
                        assert_1.default.equal(item.id, resources.doc3.id, "third document should be doc3");
                    }
                });
                assert_1.default(counter === 3, "iterator should have run 3 times");
            });
        };
        const queryIteratorNextAndMoreTest = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const queryIterator = resources.container.items.readAll({ maxItemCount: 2 });
                assert_1.default.equal(queryIterator.hasMoreResults(), true);
                const { result: doc2 } = yield queryIterator.nextItem();
                assert_1.default.equal(doc2.id, resources.doc1.id, "call queryIterator.nextItem after reset should return first document");
                const { result: doc1 } = yield queryIterator.current();
                assert_1.default.equal(doc1.id, resources.doc1.id, "call queryIterator.current after reset should return first document");
                assert_1.default.equal(queryIterator.hasMoreResults(), true);
                const { result: doc4 } = yield queryIterator.nextItem();
                assert_1.default.equal(doc4.id, resources.doc2.id, "call queryIterator.nextItem again should return second document");
                const { result: doc3 } = yield queryIterator.current();
                assert_1.default.equal(doc3.id, resources.doc2.id, "call queryIterator.current should return second document");
                assert_1.default.equal(queryIterator.hasMoreResults(), true);
                const { result: doc6 } = yield queryIterator.nextItem();
                assert_1.default.equal(doc6.id, resources.doc3.id, "call queryIterator.nextItem again should return third document");
                const { result: doc5 } = yield queryIterator.current();
                assert_1.default.equal(doc5.id, resources.doc3.id, "call queryIterator.current should return third document");
                const { result: doc7 } = yield queryIterator.nextItem();
                assert_1.default.equal(doc7, undefined, "queryIterator should return undefined if there is no elements");
            });
        };
        const queryIteratorExecuteNextTest = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                let queryIterator = resources.container.items.readAll({ maxItemCount: 2 });
                const { result: docs, headers } = yield queryIterator.executeNext();
                assert_1.default(headers !== undefined, "executeNext should pass headers as the third parameter to the callback");
                assert_1.default(headers[__1.Constants.HttpHeaders.RequestCharge] > 0, "RequestCharge has to be non-zero");
                assert_1.default.equal(docs.length, 2, "first batch size should be 2");
                assert_1.default.equal(docs[0].id, resources.doc1.id, "first batch first document should be doc1");
                assert_1.default.equal(docs[1].id, resources.doc2.id, "batch first second document should be doc2");
                const { result: docs2 } = yield queryIterator.executeNext();
                assert_1.default.equal(docs2.length, 1, "second batch size is unexpected");
                assert_1.default.equal(docs2[0].id, resources.doc3.id, "second batch element should be doc3");
                // validate Iterator.executeNext with continuation token
                queryIterator = resources.container.items.readAll({
                    maxItemCount: 2,
                    continuation: headers[__1.Constants.HttpHeaders.Continuation]
                });
                const { result: docsWithContinuation, headers: headersWithContinuation } = yield queryIterator.executeNext();
                assert_1.default(headersWithContinuation !== undefined, "executeNext should pass headers as the third parameter to the callback");
                assert_1.default(headersWithContinuation[__1.Constants.HttpHeaders.RequestCharge] > 0, "RequestCharge has to be non-zero");
                assert_1.default.equal(docsWithContinuation.length, 1, "second batch size with continuation token is unexpected");
                assert_1.default.equal(docsWithContinuation[0].id, resources.doc3.id, "second batch element should be doc3");
            });
        };
        it("nativeApi validate QueryIterator iterator toArray name based", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield queryIteratorToArrayTest();
            });
        });
        it("validate queryIterator asyncIterator", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield queryIteratorAsyncIteratorTest();
            });
        });
        it("validate queryIterator forEach", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield queryIteratorForEachTest();
            });
        });
        it("nativeApi validate queryIterator nextItem and hasMoreResults name based", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield queryIteratorNextAndMoreTest();
            });
        });
        it("nativeApi validate queryIterator iterator executeNext name based", function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield queryIteratorExecuteNextTest();
            });
        });
    });
});
//# sourceMappingURL=query.spec.js.map