"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const _1 = require(".");
const common_1 = require("./common");
const documents_1 = require("./documents");
const request_1 = require("./request");
const request_2 = require("./request/request");
const sessionContainer_1 = require("./session/sessionContainer");
/**
 * @hidden
 * @ignore
 */
class ClientContext {
    constructor(cosmosClientOptions, globalEndpointManager) {
        this.cosmosClientOptions = cosmosClientOptions;
        this.globalEndpointManager = globalEndpointManager;
        this.connectionPolicy = common_1.Helper.parseConnectionPolicy(cosmosClientOptions.connectionPolicy);
        this.sessionContainer = new sessionContainer_1.SessionContainer();
        this.requestHandler = new request_1.RequestHandler(globalEndpointManager, this.connectionPolicy, this.cosmosClientOptions.agent);
        this.partitionKeyDefinitionCache = {};
    }
    /** @ignore */
    read(path, type, id, initialHeaders, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const requestHeaders = yield request_2.getHeaders(this.cosmosClientOptions.auth, Object.assign({}, initialHeaders, this.cosmosClientOptions.defaultHeaders, (options && options.initialHeaders)), "get", path, id, type, options, undefined, this.cosmosClientOptions.connectionPolicy.UseMultipleWriteLocations);
                this.applySessionToken(path, requestHeaders);
                const request = {
                    // TODO: any
                    path,
                    operationType: _1.Constants.OperationTypes.Read,
                    client: this,
                    endpointOverride: null
                };
                // read will use ReadEndpoint since it uses GET operation
                const endpoint = yield this.globalEndpointManager.resolveServiceEndpoint(request);
                const response = yield this.requestHandler.get(endpoint, request, requestHeaders);
                this.captureSessionToken(undefined, path, _1.Constants.OperationTypes.Read, response.headers);
                return response;
            }
            catch (err) {
                this.captureSessionToken(err, path, _1.Constants.OperationTypes.Upsert, err.headers);
                throw err;
            }
        });
    }
    queryFeed(path, type, // TODO: code smell: enum?
    id, resultFn, // TODO: any
    query, options, partitionKeyRangeId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Query operations will use ReadEndpoint even though it uses
            // GET(for queryFeed) and POST(for regular query operations)
            const request = {
                // TODO: any request
                path,
                operationType: _1.Constants.OperationTypes.Query,
                client: this,
                endpointOverride: null
            };
            const endpoint = yield this.globalEndpointManager.resolveServiceEndpoint(request);
            const initialHeaders = Object.assign({}, this.cosmosClientOptions.defaultHeaders, (options && options.initialHeaders));
            if (query === undefined) {
                const reqHeaders = yield request_2.getHeaders(this.cosmosClientOptions.auth, initialHeaders, "get", path, id, type, options, partitionKeyRangeId, this.cosmosClientOptions.connectionPolicy.UseMultipleWriteLocations);
                this.applySessionToken(path, reqHeaders);
                const response = yield this.requestHandler.get(endpoint, request, reqHeaders);
                this.captureSessionToken(undefined, path, _1.Constants.OperationTypes.Query, response.headers);
                return this.processQueryFeedResponse(response, !!query, resultFn);
            }
            else {
                initialHeaders[_1.Constants.HttpHeaders.IsQuery] = "true";
                switch (this.cosmosClientOptions.queryCompatibilityMode) {
                    case documents_1.QueryCompatibilityMode.SqlQuery:
                        initialHeaders[_1.Constants.HttpHeaders.ContentType] = _1.Constants.MediaTypes.SQL;
                        break;
                    case documents_1.QueryCompatibilityMode.Query:
                    case documents_1.QueryCompatibilityMode.Default:
                    default:
                        if (typeof query === "string") {
                            query = { query }; // Converts query text to query object.
                        }
                        initialHeaders[_1.Constants.HttpHeaders.ContentType] = _1.Constants.MediaTypes.QueryJson;
                        break;
                }
                const reqHeaders = yield request_2.getHeaders(this.cosmosClientOptions.auth, initialHeaders, "post", path, id, type, options, partitionKeyRangeId, this.cosmosClientOptions.connectionPolicy.UseMultipleWriteLocations);
                this.applySessionToken(path, reqHeaders);
                const response = yield this.requestHandler.post(endpoint, request, query, reqHeaders);
                this.captureSessionToken(undefined, path, _1.Constants.OperationTypes.Query, response.headers);
                return this.processQueryFeedResponse(response, !!query, resultFn);
            }
        });
    }
    queryPartitionKeyRanges(collectionLink, query, options) {
        const path = common_1.Helper.getPathFromLink(collectionLink, "pkranges");
        const id = common_1.Helper.getIdFromLink(collectionLink);
        const cb = innerOptions => {
            return this.queryFeed(path, "pkranges", id, result => result.PartitionKeyRanges, query, innerOptions);
        };
        return new _1.QueryIterator(this, query, options, cb);
    }
    delete(path, type, id, initialHeaders, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const reqHeaders = yield request_2.getHeaders(this.cosmosClientOptions.auth, Object.assign({}, initialHeaders, this.cosmosClientOptions.defaultHeaders, (options && options.initialHeaders)), "delete", path, id, type, options, undefined, this.cosmosClientOptions.connectionPolicy.UseMultipleWriteLocations);
                const request = {
                    client: this,
                    operationType: _1.Constants.OperationTypes.Delete,
                    path,
                    resourceType: type
                };
                this.applySessionToken(path, reqHeaders);
                // deleteResource will use WriteEndpoint since it uses DELETE operation
                const endpoint = yield this.globalEndpointManager.resolveServiceEndpoint(request);
                const response = yield this.requestHandler.delete(endpoint, request, reqHeaders);
                if (common_1.Helper.parseLink(path).type !== "colls") {
                    this.captureSessionToken(undefined, path, _1.Constants.OperationTypes.Delete, response.headers);
                }
                else {
                    this.clearSessionToken(path);
                }
                return response;
            }
            catch (err) {
                this.captureSessionToken(err, path, _1.Constants.OperationTypes.Upsert, err.headers);
                throw err;
            }
        });
    }
    create(body, path, type, id, initialHeaders, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const requestHeaders = yield request_2.getHeaders(this.cosmosClientOptions.auth, Object.assign({}, initialHeaders, this.cosmosClientOptions.defaultHeaders, (options && options.initialHeaders)), "post", path, id, type, options, undefined, this.cosmosClientOptions.connectionPolicy.UseMultipleWriteLocations);
                const request = {
                    client: this,
                    operationType: _1.Constants.OperationTypes.Create,
                    path,
                    resourceType: type
                };
                // create will use WriteEndpoint since it uses POST operation
                this.applySessionToken(path, requestHeaders);
                const endpoint = yield this.globalEndpointManager.resolveServiceEndpoint(request);
                const response = yield this.requestHandler.post(endpoint, request, body, requestHeaders);
                this.captureSessionToken(undefined, path, _1.Constants.OperationTypes.Create, response.headers);
                return response;
            }
            catch (err) {
                this.captureSessionToken(err, path, _1.Constants.OperationTypes.Upsert, err.headers);
                throw err;
            }
        });
    }
    processQueryFeedResponse(res, isQuery, resultFn) {
        if (isQuery) {
            return { result: resultFn(res.result), headers: res.headers, statusCode: res.statusCode };
        }
        else {
            const newResult = resultFn(res.result).map((body) => body);
            return { result: newResult, headers: res.headers, statusCode: res.statusCode };
        }
    }
    applySessionToken(path, reqHeaders) {
        const request = this.getSessionParams(path);
        if (reqHeaders && reqHeaders[_1.Constants.HttpHeaders.SessionToken]) {
            return;
        }
        const sessionConsistency = reqHeaders[_1.Constants.HttpHeaders.ConsistencyLevel];
        if (!sessionConsistency) {
            return;
        }
        if (sessionConsistency !== documents_1.ConsistencyLevel.Session) {
            return;
        }
        if (request.resourceAddress) {
            const sessionToken = this.sessionContainer.get(request);
            if (sessionToken) {
                reqHeaders[_1.Constants.HttpHeaders.SessionToken] = sessionToken;
            }
        }
    }
    replace(resource, path, type, id, initialHeaders, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const reqHeaders = yield request_2.getHeaders(this.cosmosClientOptions.auth, Object.assign({}, initialHeaders, this.cosmosClientOptions.defaultHeaders, (options && options.initialHeaders)), "put", path, id, type, options, undefined, this.cosmosClientOptions.connectionPolicy.UseMultipleWriteLocations);
                const request = {
                    client: this,
                    operationType: _1.Constants.OperationTypes.Replace,
                    path,
                    resourceType: type
                };
                this.applySessionToken(path, reqHeaders);
                // replace will use WriteEndpoint since it uses PUT operation
                const endpoint = yield this.globalEndpointManager.resolveServiceEndpoint(reqHeaders);
                const response = yield this.requestHandler.put(endpoint, request, resource, reqHeaders);
                this.captureSessionToken(undefined, path, _1.Constants.OperationTypes.Replace, response.headers);
                return response;
            }
            catch (err) {
                this.captureSessionToken(err, path, _1.Constants.OperationTypes.Upsert, err.headers);
                throw err;
            }
        });
    }
    upsert(body, path, type, id, initialHeaders, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const requestHeaders = yield request_2.getHeaders(this.cosmosClientOptions.auth, Object.assign({}, initialHeaders, this.cosmosClientOptions.defaultHeaders, (options && options.initialHeaders)), "post", path, id, type, options, undefined, this.cosmosClientOptions.connectionPolicy.UseMultipleWriteLocations);
                const request = {
                    client: this,
                    operationType: _1.Constants.OperationTypes.Upsert,
                    path,
                    resourceType: type
                };
                common_1.Helper.setIsUpsertHeader(requestHeaders);
                this.applySessionToken(path, requestHeaders);
                // upsert will use WriteEndpoint since it uses POST operation
                const endpoint = yield this.globalEndpointManager.resolveServiceEndpoint(request);
                const response = yield this.requestHandler.post(endpoint, request, body, requestHeaders);
                this.captureSessionToken(undefined, path, _1.Constants.OperationTypes.Upsert, response.headers);
                return response;
            }
            catch (err) {
                this.captureSessionToken(err, path, _1.Constants.OperationTypes.Upsert, err.headers);
                throw err;
            }
        });
    }
    execute(sprocLink, params, // TODO: any
    options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const initialHeaders = Object.assign({}, this.cosmosClientOptions.defaultHeaders, (options && options.initialHeaders));
            // Accept a single parameter or an array of parameters.
            // Didn't add type annotation for this because we should legacy this behavior
            if (params !== null && params !== undefined && !Array.isArray(params)) {
                params = [params];
            }
            const path = common_1.Helper.getPathFromLink(sprocLink);
            const id = common_1.Helper.getIdFromLink(sprocLink);
            const headers = yield request_2.getHeaders(this.cosmosClientOptions.auth, initialHeaders, "post", path, id, "sprocs", options, undefined, this.cosmosClientOptions.connectionPolicy.UseMultipleWriteLocations);
            const request = {
                client: this,
                operationType: _1.Constants.OperationTypes.Execute,
                path,
                resourceType: "sprocs"
            };
            // executeStoredProcedure will use WriteEndpoint since it uses POST operation
            const endpoint = yield this.globalEndpointManager.resolveServiceEndpoint(request);
            return this.requestHandler.post(endpoint, request, params, headers);
        });
    }
    /**
     * Gets the Database account information.
     * @param {string} [options.urlConnection]   - The endpoint url whose database account needs to be retrieved. \
     * If not present, current client's url will be used.
     */
    getDatabaseAccount(options = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const urlConnection = options.urlConnection || this.cosmosClientOptions.endpoint;
            const requestHeaders = yield request_2.getHeaders(this.cosmosClientOptions.auth, this.cosmosClientOptions.defaultHeaders, "get", "", "", "", {}, undefined, this.cosmosClientOptions.connectionPolicy.UseMultipleWriteLocations);
            const request = {
                client: this,
                operationType: _1.Constants.OperationTypes.Read,
                path: "",
                resourceType: "DatabaseAccount"
            };
            const { result, headers } = yield this.requestHandler.get(urlConnection, request, requestHeaders);
            const databaseAccount = new documents_1.DatabaseAccount(result, headers);
            return { result: databaseAccount, headers };
        });
    }
    getWriteEndpoint() {
        return this.globalEndpointManager.getWriteEndpoint();
    }
    getReadEndpoint() {
        return this.globalEndpointManager.getReadEndpoint();
    }
    captureSessionToken(err, path, opType, resHeaders) {
        const request = this.getSessionParams(path); // TODO: any request
        request.operationType = opType;
        if (!err ||
            (!this.isMasterResource(request.resourceType) &&
                (err.code === common_1.StatusCodes.PreconditionFailed ||
                    err.code === common_1.StatusCodes.Conflict ||
                    (err.code === common_1.StatusCodes.NotFound && err.substatus !== common_1.SubStatusCodes.ReadSessionNotAvailable)))) {
            this.sessionContainer.set(request, resHeaders);
        }
    }
    // TODO: some session tests are using this, but I made them use type coercsion to call this method because I don't think it should be public.
    getSessionToken(collectionLink) {
        if (!collectionLink) {
            throw new Error("collectionLink cannot be null");
        }
        const paths = common_1.Helper.parseLink(collectionLink);
        if (paths === undefined) {
            return "";
        }
        const request = this.getSessionParams(collectionLink);
        return this.sessionContainer.get(request);
    }
    clearSessionToken(path) {
        const request = this.getSessionParams(path);
        this.sessionContainer.remove(request);
    }
    getSessionParams(resourceLink) {
        const resourceId = null;
        let resourceAddress = null;
        const parserOutput = common_1.Helper.parseLink(resourceLink);
        resourceAddress = parserOutput.objectBody.self;
        const resourceType = parserOutput.type;
        return {
            resourceId,
            resourceAddress,
            resourceType,
            isNameBased: true
        };
    }
    isMasterResource(resourceType) {
        if (resourceType === _1.Constants.Path.OffersPathSegment ||
            resourceType === _1.Constants.Path.DatabasesPathSegment ||
            resourceType === _1.Constants.Path.UsersPathSegment ||
            resourceType === _1.Constants.Path.PermissionsPathSegment ||
            resourceType === _1.Constants.Path.TopologyPathSegment ||
            resourceType === _1.Constants.Path.DatabaseAccountPathSegment ||
            resourceType === _1.Constants.Path.PartitionKeyRangesPathSegment ||
            resourceType === _1.Constants.Path.CollectionsPathSegment) {
            return true;
        }
        return false;
    }
}
exports.ClientContext = ClientContext;
//# sourceMappingURL=ClientContext.js.map