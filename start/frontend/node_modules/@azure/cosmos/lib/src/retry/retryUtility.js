"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const url = tslib_1.__importStar(require("url"));
const _1 = require(".");
const common_1 = require("../common");
const LocationRouting_1 = require("../request/LocationRouting");
const defaultRetryPolicy_1 = require("./defaultRetryPolicy");
/** @hidden */
class RetryUtility {
    /**
     * Executes the retry policy for the created request object.
     * @param {object} globalEndpointManager - an instance of GlobalEndpointManager class.
     * @param {object} body - request body. A buffer or a string.
     * @param {function} createRequestObjectStub - stub function that creates the request object.
     * @param {object} connectionPolicy - an instance of ConnectionPolicy that has the connection configs.
     * @param {RequestOptions} requestOptions - The request options.
     * @param {function} callback - the callback that will be called when the request is finished executing.
     */
    static execute(globalEndpointManager, body, createRequestObjectFunc, connectionPolicy, requestOptions, request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // TODO: any request
            const r = typeof request !== "string" ? request : { path: "", operationType: "nonReadOps" };
            const endpointDiscoveryRetryPolicy = new _1.EndpointDiscoveryRetryPolicy(globalEndpointManager, r);
            const resourceThrottleRetryPolicy = new _1.ResourceThrottleRetryPolicy(connectionPolicy.RetryOptions.MaxRetryAttemptCount, connectionPolicy.RetryOptions.FixedRetryIntervalInMilliseconds, connectionPolicy.RetryOptions.MaxWaitTimeInSeconds);
            const sessionReadRetryPolicy = new _1.SessionRetryPolicy(globalEndpointManager, r, connectionPolicy);
            const defaultRetryPolicy = new defaultRetryPolicy_1.DefaultRetryPolicy(request.operationType);
            return this.apply(body, createRequestObjectFunc, connectionPolicy, requestOptions, endpointDiscoveryRetryPolicy, resourceThrottleRetryPolicy, sessionReadRetryPolicy, defaultRetryPolicy, globalEndpointManager, request, {});
        });
    }
    /**
     * Applies the retry policy for the created request object.
     * @param {object} body - request body. A buffer or a string.
     * @param {function} createRequestObjectFunc - function that creates the request object.
     * @param {object} connectionPolicy - an instance of ConnectionPolicy that has the connection configs.
     * @param {RequestOptions} requestOptions - The request options.
     * @param {EndpointDiscoveryRetryPolicy} endpointDiscoveryRetryPolicy - The endpoint discovery retry policy \
     * instance.
     * @param {ResourceThrottleRetryPolicy} resourceThrottleRetryPolicy - The resource throttle retry policy instance.
     * @param {function} callback - the callback that will be called when the response is retrieved and processed.
     */
    static apply(body, createRequestObjectFunc, connectionPolicy, requestOptions, endpointDiscoveryRetryPolicy, resourceThrottleRetryPolicy, sessionReadRetryPolicy, defaultRetryPolicy, globalEndpointManager, request, retryContext) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // TODO: any response
            const httpsRequest = createRequestObjectFunc(connectionPolicy, requestOptions, body);
            if (!request.locationRouting) {
                request.locationRouting = new LocationRouting_1.LocationRouting();
            }
            request.locationRouting.clearRouteToLocation();
            if (retryContext) {
                request.locationRouting.routeToLocation(retryContext.retryCount || 0, !retryContext.retryRequestOnPreferredLocations);
                if (retryContext.clearSessionTokenNotAvailable) {
                    request.client.clearSessionToken(request.path);
                }
            }
            const locationEndpoint = yield globalEndpointManager.resolveServiceEndpoint(request);
            requestOptions = this.modifyRequestOptions(requestOptions, url.parse(locationEndpoint));
            request.locationRouting.routeToLocation(locationEndpoint);
            try {
                const response = yield httpsRequest;
                response.headers[common_1.Constants.ThrottleRetryCount] = resourceThrottleRetryPolicy.currentRetryAttemptCount;
                response.headers[common_1.Constants.ThrottleRetryWaitTimeInMs] =
                    resourceThrottleRetryPolicy.cummulativeWaitTimeinMilliseconds;
                return response;
            }
            catch (err) {
                // TODO: any error
                let retryPolicy = null;
                const headers = err.headers || {};
                if (err.code === common_1.StatusCodes.Forbidden && err.substatus === common_1.SubStatusCodes.WriteForbidden) {
                    retryPolicy = endpointDiscoveryRetryPolicy;
                }
                else if (err.code === common_1.StatusCodes.TooManyRequests) {
                    retryPolicy = resourceThrottleRetryPolicy;
                }
                else if (err.code === common_1.StatusCodes.NotFound && err.substatus === common_1.SubStatusCodes.ReadSessionNotAvailable) {
                    retryPolicy = sessionReadRetryPolicy;
                }
                else {
                    retryPolicy = defaultRetryPolicy;
                }
                const results = yield retryPolicy.shouldRetry(err, retryContext, locationEndpoint);
                if (!results) {
                    headers[common_1.Constants.ThrottleRetryCount] = resourceThrottleRetryPolicy.currentRetryAttemptCount;
                    headers[common_1.Constants.ThrottleRetryWaitTimeInMs] = resourceThrottleRetryPolicy.cummulativeWaitTimeinMilliseconds;
                    err.headers = Object.assign({}, err.headers, headers);
                    throw err;
                }
                else {
                    request.retryCount++;
                    const newUrl = results[1]; // TODO: any hack
                    if (newUrl !== undefined) {
                        RetryUtility.modifyRequestOptions(requestOptions, url.parse(newUrl));
                    }
                    yield common_1.Helper.sleep(retryPolicy.retryAfterInMilliseconds);
                    return this.apply(body, createRequestObjectFunc, connectionPolicy, requestOptions, endpointDiscoveryRetryPolicy, resourceThrottleRetryPolicy, sessionReadRetryPolicy, defaultRetryPolicy, globalEndpointManager, request, retryContext);
                }
            }
        });
    }
    static modifyRequestOptions(oldRequestOptions, // TODO: any hack is bad
    newUrl) {
        // TODO: any hack is bad
        const properties = Object.keys(newUrl);
        for (const index in properties) {
            if (properties[index] !== "path") {
                oldRequestOptions[properties[index]] = newUrl[properties[index]];
            }
        }
        return oldRequestOptions;
    }
}
exports.RetryUtility = RetryUtility;
//# sourceMappingURL=retryUtility.js.map