"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const common_1 = require("../common");
/**
 * This class implements the retry policy for session consistent reads.
 * @hidden
 */
class SessionRetryPolicy {
    /**
     * @constructor SessionReadRetryPolicy
     * @param {object} globalEndpointManager                           - The GlobalEndpointManager instance.
     * @property {object} request                                      - The Http request information
     */
    constructor(globalEndpointManager, request, connectionPolicy) {
        this.globalEndpointManager = globalEndpointManager;
        this.request = request;
        this.connectionPolicy = connectionPolicy;
        /** Current retry attempt count. */
        this.currentRetryAttemptCount = 0;
        /** Retry interval in milliseconds. */
        this.retryAfterInMilliseconds = 0;
    }
    /**
     * Determines whether the request should be retried or not.
     * @param {object} err - Error returned by the request.
     * @param {function} callback - The callback function which takes bool argument which specifies whether the request\
     * will be retried or not.
     */
    shouldRetry(err, retryContext) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!err) {
                return false;
            }
            if (!retryContext) {
                return false;
            }
            if (!this.connectionPolicy.EnableEndpointDiscovery) {
                return false;
            }
            if (this.globalEndpointManager.canUseMultipleWriteLocations(this.request)) {
                // If we can write to multiple locations, we should against every write endpoint until we succeed
                const endpoints = common_1.Helper.isReadRequest(this.request)
                    ? yield this.globalEndpointManager.getReadEndpoints()
                    : yield this.globalEndpointManager.getWriteEndpoints();
                if (this.currentRetryAttemptCount > endpoints.length) {
                    return false;
                }
                else {
                    retryContext.retryCount = ++this.currentRetryAttemptCount - 1;
                    retryContext.retryRequestOnPreferredLocations = this.currentRetryAttemptCount > 1;
                    retryContext.clearSessionTokenNotAvailable = this.currentRetryAttemptCount === endpoints.length;
                    return true;
                }
            }
            else {
                if (this.currentRetryAttemptCount > 1) {
                    return false;
                }
                else {
                    retryContext.retryCount = ++this.currentRetryAttemptCount - 1;
                    retryContext.retryRequestOnPreferredLocations = false; // Forces all operations to primary write endpoint
                    retryContext.clearSessionTokenNotAvailable = true;
                    return true;
                }
            }
        });
    }
}
exports.SessionRetryPolicy = SessionRetryPolicy;
//# sourceMappingURL=sessionRetryPolicy.js.map